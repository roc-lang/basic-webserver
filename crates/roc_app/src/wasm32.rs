// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::non_canonical_partial_ord_impl)]

use roc_std::roc_refcounted_noop_impl;
use roc_std::RocRefcounted;

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct ConnectErr_Unrecognized {
    pub f0: i32,
    pub f1: roc_std::RocStr,
}

impl roc_std::RocRefcounted for ConnectErr_Unrecognized {
    fn inc(&mut self) {
        self.f1.inc();
    }
    fn dec(&mut self) {
        self.f1.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_ConnectErr {
    AddrInUse = 0,
    AddrNotAvailable = 1,
    ConnectionRefused = 2,
    Interrupted = 3,
    PermissionDenied = 4,
    TimedOut = 5,
    Unrecognized = 6,
    Unsupported = 7,
}

impl core::fmt::Debug for discriminant_ConnectErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::AddrInUse => f.write_str("discriminant_ConnectErr::AddrInUse"),
            Self::AddrNotAvailable => f.write_str("discriminant_ConnectErr::AddrNotAvailable"),
            Self::ConnectionRefused => f.write_str("discriminant_ConnectErr::ConnectionRefused"),
            Self::Interrupted => f.write_str("discriminant_ConnectErr::Interrupted"),
            Self::PermissionDenied => f.write_str("discriminant_ConnectErr::PermissionDenied"),
            Self::TimedOut => f.write_str("discriminant_ConnectErr::TimedOut"),
            Self::Unrecognized => f.write_str("discriminant_ConnectErr::Unrecognized"),
            Self::Unsupported => f.write_str("discriminant_ConnectErr::Unsupported"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_ConnectErr);

#[repr(C, align(4))]
pub union union_ConnectErr {
    AddrInUse: (),
    AddrNotAvailable: (),
    ConnectionRefused: (),
    Interrupted: (),
    PermissionDenied: (),
    TimedOut: (),
    Unrecognized: core::mem::ManuallyDrop<ConnectErr_Unrecognized>,
    Unsupported: (),
}

// const _SIZE_CHECK_union_ConnectErr: () = assert!(core::mem::size_of::<union_ConnectErr>() == 20);
const _ALIGN_CHECK_union_ConnectErr: () = assert!(core::mem::align_of::<union_ConnectErr>() == 4);

const _SIZE_CHECK_ConnectErr: () = assert!(core::mem::size_of::<ConnectErr>() == 20);
const _ALIGN_CHECK_ConnectErr: () = assert!(core::mem::align_of::<ConnectErr>() == 4);

impl ConnectErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ConnectErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ConnectErr>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ConnectErr) {
        let discriminant_ptr: *mut discriminant_ConnectErr = (self as *mut ConnectErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ConnectErr {
    payload: union_ConnectErr,
    discriminant: discriminant_ConnectErr,
}

impl Clone for ConnectErr {
    fn clone(&self) -> Self {
        use discriminant_ConnectErr::*;

        let payload = unsafe {
            match self.discriminant {
                AddrInUse => union_ConnectErr {
                    AddrInUse: self.payload.AddrInUse.clone(),
                },
                AddrNotAvailable => union_ConnectErr {
                    AddrNotAvailable: self.payload.AddrNotAvailable.clone(),
                },
                ConnectionRefused => union_ConnectErr {
                    ConnectionRefused: self.payload.ConnectionRefused.clone(),
                },
                Interrupted => union_ConnectErr {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                PermissionDenied => union_ConnectErr {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                TimedOut => union_ConnectErr {
                    TimedOut: self.payload.TimedOut.clone(),
                },
                Unrecognized => union_ConnectErr {
                    Unrecognized: self.payload.Unrecognized.clone(),
                },
                Unsupported => union_ConnectErr {
                    Unsupported: self.payload.Unsupported.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ConnectErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ConnectErr::*;

        unsafe {
            match self.discriminant {
                AddrInUse => {
                    let field: &() = &self.payload.AddrInUse;
                    f.debug_tuple("ConnectErr::AddrInUse").field(field).finish()
                }
                AddrNotAvailable => {
                    let field: &() = &self.payload.AddrNotAvailable;
                    f.debug_tuple("ConnectErr::AddrNotAvailable")
                        .field(field)
                        .finish()
                }
                ConnectionRefused => {
                    let field: &() = &self.payload.ConnectionRefused;
                    f.debug_tuple("ConnectErr::ConnectionRefused")
                        .field(field)
                        .finish()
                }
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("ConnectErr::Interrupted")
                        .field(field)
                        .finish()
                }
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("ConnectErr::PermissionDenied")
                        .field(field)
                        .finish()
                }
                TimedOut => {
                    let field: &() = &self.payload.TimedOut;
                    f.debug_tuple("ConnectErr::TimedOut").field(field).finish()
                }
                Unrecognized => {
                    let field: &ConnectErr_Unrecognized = &self.payload.Unrecognized;
                    f.debug_tuple("ConnectErr::Unrecognized")
                        .field(field)
                        .finish()
                }
                Unsupported => {
                    let field: &() = &self.payload.Unsupported;
                    f.debug_tuple("ConnectErr::Unsupported")
                        .field(field)
                        .finish()
                }
            }
        }
    }
}

impl Eq for ConnectErr {}

impl PartialEq for ConnectErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ConnectErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                AddrInUse => self.payload.AddrInUse == other.payload.AddrInUse,
                AddrNotAvailable => self.payload.AddrNotAvailable == other.payload.AddrNotAvailable,
                ConnectionRefused => {
                    self.payload.ConnectionRefused == other.payload.ConnectionRefused
                }
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                TimedOut => self.payload.TimedOut == other.payload.TimedOut,
                Unrecognized => self.payload.Unrecognized == other.payload.Unrecognized,
                Unsupported => self.payload.Unsupported == other.payload.Unsupported,
            }
        }
    }
}

impl Ord for ConnectErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ConnectErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ConnectErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    AddrInUse => self.payload.AddrInUse.partial_cmp(&other.payload.AddrInUse),
                    AddrNotAvailable => self
                        .payload
                        .AddrNotAvailable
                        .partial_cmp(&other.payload.AddrNotAvailable),
                    ConnectionRefused => self
                        .payload
                        .ConnectionRefused
                        .partial_cmp(&other.payload.ConnectionRefused),
                    Interrupted => self
                        .payload
                        .Interrupted
                        .partial_cmp(&other.payload.Interrupted),
                    PermissionDenied => self
                        .payload
                        .PermissionDenied
                        .partial_cmp(&other.payload.PermissionDenied),
                    TimedOut => self.payload.TimedOut.partial_cmp(&other.payload.TimedOut),
                    Unrecognized => self
                        .payload
                        .Unrecognized
                        .partial_cmp(&other.payload.Unrecognized),
                    Unsupported => self
                        .payload
                        .Unsupported
                        .partial_cmp(&other.payload.Unsupported),
                }
            },
        }
    }
}

impl core::hash::Hash for ConnectErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ConnectErr::*;

        unsafe {
            match self.discriminant {
                AddrInUse => self.payload.AddrInUse.hash(state),
                AddrNotAvailable => self.payload.AddrNotAvailable.hash(state),
                ConnectionRefused => self.payload.ConnectionRefused.hash(state),
                Interrupted => self.payload.Interrupted.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                TimedOut => self.payload.TimedOut.hash(state),
                Unrecognized => self.payload.Unrecognized.hash(state),
                Unsupported => self.payload.Unsupported.hash(state),
            }
        }
    }
}

impl ConnectErr {
    pub fn is_AddrInUse(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::AddrInUse)
    }

    pub fn is_AddrNotAvailable(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::AddrNotAvailable)
    }

    pub fn is_ConnectionRefused(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_ConnectErr::ConnectionRefused
        )
    }

    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::Interrupted)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::PermissionDenied)
    }

    pub fn is_TimedOut(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::TimedOut)
    }

    pub fn unwrap_Unrecognized(mut self) -> ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_ConnectErr::Unrecognized);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unrecognized) }
    }

    pub fn borrow_Unrecognized(&self) -> &ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_ConnectErr::Unrecognized);
        use core::borrow::Borrow;
        unsafe { self.payload.Unrecognized.borrow() }
    }

    pub fn borrow_mut_Unrecognized(&mut self) -> &mut ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_ConnectErr::Unrecognized);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Unrecognized.borrow_mut() }
    }

    pub fn is_Unrecognized(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::Unrecognized)
    }

    pub fn is_Unsupported(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectErr::Unsupported)
    }
}

impl ConnectErr {
    pub fn AddrInUse() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::AddrInUse,
            payload: union_ConnectErr { AddrInUse: () },
        }
    }

    pub fn AddrNotAvailable() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::AddrNotAvailable,
            payload: union_ConnectErr {
                AddrNotAvailable: (),
            },
        }
    }

    pub fn ConnectionRefused() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::ConnectionRefused,
            payload: union_ConnectErr {
                ConnectionRefused: (),
            },
        }
    }

    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::Interrupted,
            payload: union_ConnectErr { Interrupted: () },
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::PermissionDenied,
            payload: union_ConnectErr {
                PermissionDenied: (),
            },
        }
    }

    pub fn TimedOut() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::TimedOut,
            payload: union_ConnectErr { TimedOut: () },
        }
    }

    pub fn Unrecognized(payload: ConnectErr_Unrecognized) -> Self {
        Self {
            discriminant: discriminant_ConnectErr::Unrecognized,
            payload: union_ConnectErr {
                Unrecognized: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Unsupported() -> Self {
        Self {
            discriminant: discriminant_ConnectErr::Unsupported,
            payload: union_ConnectErr { Unsupported: () },
        }
    }
}

impl Drop for ConnectErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ConnectErr::AddrInUse => {}
            discriminant_ConnectErr::AddrNotAvailable => {}
            discriminant_ConnectErr::ConnectionRefused => {}
            discriminant_ConnectErr::Interrupted => {}
            discriminant_ConnectErr::PermissionDenied => {}
            discriminant_ConnectErr::TimedOut => {}
            discriminant_ConnectErr::Unrecognized => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Unrecognized)
            },
            discriminant_ConnectErr::Unsupported => {}
        }
    }
}

impl roc_std::RocRefcounted for ConnectErr {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_ConnectResult {
    Connected = 0,
    Error = 1,
}

impl core::fmt::Debug for discriminant_ConnectResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Connected => f.write_str("discriminant_ConnectResult::Connected"),
            Self::Error => f.write_str("discriminant_ConnectResult::Error"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_ConnectResult);

#[repr(C, align(8))]
pub union union_ConnectResult {
    Connected: u64,
    Error: core::mem::ManuallyDrop<ConnectErr>,
}

const _SIZE_CHECK_union_ConnectResult: () =
    assert!(core::mem::size_of::<union_ConnectResult>() == 24);
const _ALIGN_CHECK_union_ConnectResult: () =
    assert!(core::mem::align_of::<union_ConnectResult>() == 8);

const _SIZE_CHECK_ConnectResult: () = assert!(core::mem::size_of::<ConnectResult>() == 32);
const _ALIGN_CHECK_ConnectResult: () = assert!(core::mem::align_of::<ConnectResult>() == 8);

impl ConnectResult {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ConnectResult {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ConnectResult>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ConnectResult) {
        let discriminant_ptr: *mut discriminant_ConnectResult = (self as *mut ConnectResult).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ConnectResult {
    payload: union_ConnectResult,
    discriminant: discriminant_ConnectResult,
}

impl Clone for ConnectResult {
    fn clone(&self) -> Self {
        use discriminant_ConnectResult::*;

        let payload = unsafe {
            match self.discriminant {
                Connected => union_ConnectResult {
                    Connected: self.payload.Connected.clone(),
                },
                Error => union_ConnectResult {
                    Error: self.payload.Error.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ConnectResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ConnectResult::*;

        unsafe {
            match self.discriminant {
                Connected => {
                    let field: &u64 = &self.payload.Connected;
                    f.debug_tuple("ConnectResult::Connected")
                        .field(field)
                        .finish()
                }
                Error => {
                    let field: &ConnectErr = &self.payload.Error;
                    f.debug_tuple("ConnectResult::Error").field(field).finish()
                }
            }
        }
    }
}

impl Eq for ConnectResult {}

impl PartialEq for ConnectResult {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ConnectResult::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Connected => self.payload.Connected == other.payload.Connected,
                Error => self.payload.Error == other.payload.Error,
            }
        }
    }
}

impl Ord for ConnectResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ConnectResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ConnectResult::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Connected => self.payload.Connected.partial_cmp(&other.payload.Connected),
                    Error => self.payload.Error.partial_cmp(&other.payload.Error),
                }
            },
        }
    }
}

impl core::hash::Hash for ConnectResult {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ConnectResult::*;

        unsafe {
            match self.discriminant {
                Connected => self.payload.Connected.hash(state),
                Error => self.payload.Error.hash(state),
            }
        }
    }
}

impl ConnectResult {
    pub fn unwrap_Connected(mut self) -> u64 {
        debug_assert_eq!(self.discriminant, discriminant_ConnectResult::Connected);
        unsafe { self.payload.Connected }
    }

    pub fn borrow_Connected(&self) -> u64 {
        debug_assert_eq!(self.discriminant, discriminant_ConnectResult::Connected);
        unsafe { self.payload.Connected }
    }

    pub fn borrow_mut_Connected(&mut self) -> &mut u64 {
        debug_assert_eq!(self.discriminant, discriminant_ConnectResult::Connected);
        unsafe { &mut self.payload.Connected }
    }

    pub fn is_Connected(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectResult::Connected)
    }

    pub fn unwrap_Error(mut self) -> ConnectErr {
        debug_assert_eq!(self.discriminant, discriminant_ConnectResult::Error);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Error) }
    }

    pub fn borrow_Error(&self) -> &ConnectErr {
        debug_assert_eq!(self.discriminant, discriminant_ConnectResult::Error);
        use core::borrow::Borrow;
        unsafe { self.payload.Error.borrow() }
    }

    pub fn borrow_mut_Error(&mut self) -> &mut ConnectErr {
        debug_assert_eq!(self.discriminant, discriminant_ConnectResult::Error);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Error.borrow_mut() }
    }

    pub fn is_Error(&self) -> bool {
        matches!(self.discriminant, discriminant_ConnectResult::Error)
    }
}

impl ConnectResult {
    pub fn Connected(payload: u64) -> Self {
        Self {
            discriminant: discriminant_ConnectResult::Connected,
            payload: union_ConnectResult { Connected: payload },
        }
    }

    pub fn Error(payload: ConnectErr) -> Self {
        Self {
            discriminant: discriminant_ConnectResult::Error,
            payload: union_ConnectResult {
                Error: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for ConnectResult {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ConnectResult::Connected => {}
            discriminant_ConnectResult::Error => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Error)
            },
        }
    }
}

impl roc_std::RocRefcounted for ConnectResult {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_SqliteValue {
    Bytes = 0,
    Integer = 1,
    Null = 2,
    Real = 3,
    String = 4,
}

impl core::fmt::Debug for discriminant_SqliteValue {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Bytes => f.write_str("discriminant_SqliteValue::Bytes"),
            Self::Integer => f.write_str("discriminant_SqliteValue::Integer"),
            Self::Null => f.write_str("discriminant_SqliteValue::Null"),
            Self::Real => f.write_str("discriminant_SqliteValue::Real"),
            Self::String => f.write_str("discriminant_SqliteValue::String"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_SqliteValue);

#[repr(C, align(8))]
pub union union_SqliteValue {
    Bytes: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    Integer: i64,
    Null: (),
    Real: f64,
    String: core::mem::ManuallyDrop<roc_std::RocStr>,
}

const _SIZE_CHECK_union_SqliteValue: () = assert!(core::mem::size_of::<union_SqliteValue>() == 16);
const _ALIGN_CHECK_union_SqliteValue: () = assert!(core::mem::align_of::<union_SqliteValue>() == 8);

const _SIZE_CHECK_SqliteValue: () = assert!(core::mem::size_of::<SqliteValue>() == 24);
const _ALIGN_CHECK_SqliteValue: () = assert!(core::mem::align_of::<SqliteValue>() == 8);

impl SqliteValue {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_SqliteValue {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_SqliteValue>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_SqliteValue) {
        let discriminant_ptr: *mut discriminant_SqliteValue = (self as *mut SqliteValue).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct SqliteValue {
    payload: union_SqliteValue,
    discriminant: discriminant_SqliteValue,
}

impl Clone for SqliteValue {
    fn clone(&self) -> Self {
        use discriminant_SqliteValue::*;

        let payload = unsafe {
            match self.discriminant {
                Bytes => union_SqliteValue {
                    Bytes: self.payload.Bytes.clone(),
                },
                Integer => union_SqliteValue {
                    Integer: self.payload.Integer.clone(),
                },
                Null => union_SqliteValue {
                    Null: self.payload.Null.clone(),
                },
                Real => union_SqliteValue {
                    Real: self.payload.Real.clone(),
                },
                String => union_SqliteValue {
                    String: self.payload.String.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for SqliteValue {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_SqliteValue::*;

        unsafe {
            match self.discriminant {
                Bytes => {
                    let field: &roc_std::RocList<u8> = &self.payload.Bytes;
                    f.debug_tuple("SqliteValue::Bytes").field(field).finish()
                }
                Integer => {
                    let field: &i64 = &self.payload.Integer;
                    f.debug_tuple("SqliteValue::Integer").field(field).finish()
                }
                Null => {
                    let field: &() = &self.payload.Null;
                    f.debug_tuple("SqliteValue::Null").field(field).finish()
                }
                Real => {
                    let field: &f64 = &self.payload.Real;
                    f.debug_tuple("SqliteValue::Real").field(field).finish()
                }
                String => {
                    let field: &roc_std::RocStr = &self.payload.String;
                    f.debug_tuple("SqliteValue::String").field(field).finish()
                }
            }
        }
    }
}

impl PartialEq for SqliteValue {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_SqliteValue::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Bytes => self.payload.Bytes == other.payload.Bytes,
                Integer => self.payload.Integer == other.payload.Integer,
                Null => self.payload.Null == other.payload.Null,
                Real => self.payload.Real == other.payload.Real,
                String => self.payload.String == other.payload.String,
            }
        }
    }
}

impl PartialOrd for SqliteValue {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_SqliteValue::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Bytes => self.payload.Bytes.partial_cmp(&other.payload.Bytes),
                    Integer => self.payload.Integer.partial_cmp(&other.payload.Integer),
                    Null => self.payload.Null.partial_cmp(&other.payload.Null),
                    Real => self.payload.Real.partial_cmp(&other.payload.Real),
                    String => self.payload.String.partial_cmp(&other.payload.String),
                }
            },
        }
    }
}

impl SqliteValue {
    pub fn unwrap_Bytes(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Bytes);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Bytes) }
    }

    pub fn borrow_Bytes(&self) -> &roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Bytes);
        use core::borrow::Borrow;
        unsafe { self.payload.Bytes.borrow() }
    }

    pub fn borrow_mut_Bytes(&mut self) -> &mut roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Bytes);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Bytes.borrow_mut() }
    }

    pub fn is_Bytes(&self) -> bool {
        matches!(self.discriminant, discriminant_SqliteValue::Bytes)
    }

    pub fn unwrap_Integer(mut self) -> i64 {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Integer);
        unsafe { self.payload.Integer }
    }

    pub fn borrow_Integer(&self) -> i64 {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Integer);
        unsafe { self.payload.Integer }
    }

    pub fn borrow_mut_Integer(&mut self) -> &mut i64 {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Integer);
        unsafe { &mut self.payload.Integer }
    }

    pub fn is_Integer(&self) -> bool {
        matches!(self.discriminant, discriminant_SqliteValue::Integer)
    }

    pub fn is_Null(&self) -> bool {
        matches!(self.discriminant, discriminant_SqliteValue::Null)
    }

    pub fn unwrap_Real(mut self) -> f64 {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Real);
        unsafe { self.payload.Real }
    }

    pub fn borrow_Real(&self) -> f64 {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Real);
        unsafe { self.payload.Real }
    }

    pub fn borrow_mut_Real(&mut self) -> &mut f64 {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::Real);
        unsafe { &mut self.payload.Real }
    }

    pub fn is_Real(&self) -> bool {
        matches!(self.discriminant, discriminant_SqliteValue::Real)
    }

    pub fn unwrap_String(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::String);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.String) }
    }

    pub fn borrow_String(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::String);
        use core::borrow::Borrow;
        unsafe { self.payload.String.borrow() }
    }

    pub fn borrow_mut_String(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_SqliteValue::String);
        use core::borrow::BorrowMut;
        unsafe { self.payload.String.borrow_mut() }
    }

    pub fn is_String(&self) -> bool {
        matches!(self.discriminant, discriminant_SqliteValue::String)
    }
}

impl SqliteValue {
    pub fn Bytes(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_SqliteValue::Bytes,
            payload: union_SqliteValue {
                Bytes: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Integer(payload: i64) -> Self {
        Self {
            discriminant: discriminant_SqliteValue::Integer,
            payload: union_SqliteValue { Integer: payload },
        }
    }

    pub fn Null() -> Self {
        Self {
            discriminant: discriminant_SqliteValue::Null,
            payload: union_SqliteValue { Null: () },
        }
    }

    pub fn Real(payload: f64) -> Self {
        Self {
            discriminant: discriminant_SqliteValue::Real,
            payload: union_SqliteValue { Real: payload },
        }
    }

    pub fn String(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_SqliteValue::String,
            payload: union_SqliteValue {
                String: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for SqliteValue {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_SqliteValue::Bytes => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Bytes)
            },
            discriminant_SqliteValue::Integer => {}
            discriminant_SqliteValue::Null => {}
            discriminant_SqliteValue::Real => {}
            discriminant_SqliteValue::String => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.String)
            },
        }
    }
}

impl roc_std::RocRefcounted for SqliteValue {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd)]
#[repr(C)]
pub struct SqliteBindings {
    pub value: SqliteValue,
    pub name: roc_std::RocStr,
}

impl roc_std::RocRefcounted for SqliteBindings {
    fn inc(&mut self) {
        self.value.inc();
        self.name.inc();
    }
    fn dec(&mut self) {
        self.value.dec();
        self.name.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct SqliteError {
    pub code: i64,
    pub message: roc_std::RocStr,
}

impl roc_std::RocRefcounted for SqliteError {
    fn inc(&mut self) {
        self.message.inc();
    }
    fn dec(&mut self) {
        self.message.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct InternalCommand {
    pub args: roc_std::RocList<roc_std::RocStr>,
    pub envs: roc_std::RocList<roc_std::RocStr>,
    pub program: roc_std::RocStr,
    pub clearEnvs: bool,
}

impl roc_std::RocRefcounted for InternalCommand {
    fn inc(&mut self) {
        self.args.inc();
        self.envs.inc();
        self.program.inc();
    }
    fn dec(&mut self) {
        self.args.dec();
        self.envs.dec();
        self.program.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_InternalCommandErr {
    ExitCode = 0,
    IOError = 1,
    KilledBySignal = 2,
}

impl core::fmt::Debug for discriminant_InternalCommandErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ExitCode => f.write_str("discriminant_InternalCommandErr::ExitCode"),
            Self::IOError => f.write_str("discriminant_InternalCommandErr::IOError"),
            Self::KilledBySignal => f.write_str("discriminant_InternalCommandErr::KilledBySignal"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_InternalCommandErr);

#[repr(C, align(4))]
pub union union_InternalCommandErr {
    ExitCode: i32,
    IOError: core::mem::ManuallyDrop<roc_std::RocStr>,
    KilledBySignal: (),
}

const _SIZE_CHECK_union_InternalCommandErr: () =
    assert!(core::mem::size_of::<union_InternalCommandErr>() == 12);
const _ALIGN_CHECK_union_InternalCommandErr: () =
    assert!(core::mem::align_of::<union_InternalCommandErr>() == 4);

const _SIZE_CHECK_InternalCommandErr: () =
    assert!(core::mem::size_of::<InternalCommandErr>() == 16);
const _ALIGN_CHECK_InternalCommandErr: () =
    assert!(core::mem::align_of::<InternalCommandErr>() == 4);

impl InternalCommandErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_InternalCommandErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_InternalCommandErr>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_InternalCommandErr) {
        let discriminant_ptr: *mut discriminant_InternalCommandErr =
            (self as *mut InternalCommandErr).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct InternalCommandErr {
    payload: union_InternalCommandErr,
    discriminant: discriminant_InternalCommandErr,
}

impl Clone for InternalCommandErr {
    fn clone(&self) -> Self {
        use discriminant_InternalCommandErr::*;

        let payload = unsafe {
            match self.discriminant {
                ExitCode => union_InternalCommandErr {
                    ExitCode: self.payload.ExitCode.clone(),
                },
                IOError => union_InternalCommandErr {
                    IOError: self.payload.IOError.clone(),
                },
                KilledBySignal => union_InternalCommandErr {
                    KilledBySignal: self.payload.KilledBySignal.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for InternalCommandErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_InternalCommandErr::*;

        unsafe {
            match self.discriminant {
                ExitCode => {
                    let field: &i32 = &self.payload.ExitCode;
                    f.debug_tuple("InternalCommandErr::ExitCode")
                        .field(field)
                        .finish()
                }
                IOError => {
                    let field: &roc_std::RocStr = &self.payload.IOError;
                    f.debug_tuple("InternalCommandErr::IOError")
                        .field(field)
                        .finish()
                }
                KilledBySignal => {
                    let field: &() = &self.payload.KilledBySignal;
                    f.debug_tuple("InternalCommandErr::KilledBySignal")
                        .field(field)
                        .finish()
                }
            }
        }
    }
}

impl Eq for InternalCommandErr {}

impl PartialEq for InternalCommandErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_InternalCommandErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                ExitCode => self.payload.ExitCode == other.payload.ExitCode,
                IOError => self.payload.IOError == other.payload.IOError,
                KilledBySignal => self.payload.KilledBySignal == other.payload.KilledBySignal,
            }
        }
    }
}

impl Ord for InternalCommandErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for InternalCommandErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_InternalCommandErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    ExitCode => self.payload.ExitCode.partial_cmp(&other.payload.ExitCode),
                    IOError => self.payload.IOError.partial_cmp(&other.payload.IOError),
                    KilledBySignal => self
                        .payload
                        .KilledBySignal
                        .partial_cmp(&other.payload.KilledBySignal),
                }
            },
        }
    }
}

impl core::hash::Hash for InternalCommandErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_InternalCommandErr::*;

        unsafe {
            match self.discriminant {
                ExitCode => self.payload.ExitCode.hash(state),
                IOError => self.payload.IOError.hash(state),
                KilledBySignal => self.payload.KilledBySignal.hash(state),
            }
        }
    }
}

impl InternalCommandErr {
    pub fn unwrap_ExitCode(mut self) -> i32 {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::ExitCode);
        unsafe { self.payload.ExitCode }
    }

    pub fn borrow_ExitCode(&self) -> i32 {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::ExitCode);
        unsafe { self.payload.ExitCode }
    }

    pub fn borrow_mut_ExitCode(&mut self) -> &mut i32 {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::ExitCode);
        unsafe { &mut self.payload.ExitCode }
    }

    pub fn is_ExitCode(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalCommandErr::ExitCode)
    }

    pub fn unwrap_IOError(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::IOError);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.IOError) }
    }

    pub fn borrow_IOError(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::IOError);
        use core::borrow::Borrow;
        unsafe { self.payload.IOError.borrow() }
    }

    pub fn borrow_mut_IOError(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::IOError);
        use core::borrow::BorrowMut;
        unsafe { self.payload.IOError.borrow_mut() }
    }

    pub fn is_IOError(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalCommandErr::IOError)
    }

    pub fn is_KilledBySignal(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_InternalCommandErr::KilledBySignal
        )
    }
}

impl InternalCommandErr {
    pub fn ExitCode(payload: i32) -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::ExitCode,
            payload: union_InternalCommandErr { ExitCode: payload },
        }
    }

    pub fn IOError(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::IOError,
            payload: union_InternalCommandErr {
                IOError: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn KilledBySignal() -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::KilledBySignal,
            payload: union_InternalCommandErr { KilledBySignal: () },
        }
    }
}

impl Drop for InternalCommandErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_InternalCommandErr::ExitCode => {}
            discriminant_InternalCommandErr::IOError => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.IOError)
            },
            discriminant_InternalCommandErr::KilledBySignal => {}
        }
    }
}

impl roc_std::RocRefcounted for InternalCommandErr {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct InternalOutput {
    pub status: roc_std::RocResult<(), InternalCommandErr>,
    pub stderr: roc_std::RocList<u8>,
    pub stdout: roc_std::RocList<u8>,
}

impl roc_std::RocRefcounted for InternalOutput {
    fn inc(&mut self) {
        self.status.inc();
        self.stderr.inc();
        self.stdout.inc();
    }
    fn dec(&mut self) {
        self.status.dec();
        self.stderr.dec();
        self.stdout.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_StreamErr {
    BrokenPipe = 0,
    ConnectionRefused = 1,
    ConnectionReset = 2,
    Interrupted = 3,
    OutOfMemory = 4,
    PermissionDenied = 5,
    Unrecognized = 6,
}

impl core::fmt::Debug for discriminant_StreamErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BrokenPipe => f.write_str("discriminant_StreamErr::BrokenPipe"),
            Self::ConnectionRefused => f.write_str("discriminant_StreamErr::ConnectionRefused"),
            Self::ConnectionReset => f.write_str("discriminant_StreamErr::ConnectionReset"),
            Self::Interrupted => f.write_str("discriminant_StreamErr::Interrupted"),
            Self::OutOfMemory => f.write_str("discriminant_StreamErr::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_StreamErr::PermissionDenied"),
            Self::Unrecognized => f.write_str("discriminant_StreamErr::Unrecognized"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_StreamErr);

#[repr(C, align(4))]
pub union union_StreamErr {
    BrokenPipe: (),
    ConnectionRefused: (),
    ConnectionReset: (),
    Interrupted: (),
    OutOfMemory: (),
    PermissionDenied: (),
    Unrecognized: core::mem::ManuallyDrop<ConnectErr_Unrecognized>,
}

// const _SIZE_CHECK_union_StreamErr: () = assert!(core::mem::size_of::<union_StreamErr>() == 20);
const _ALIGN_CHECK_union_StreamErr: () = assert!(core::mem::align_of::<union_StreamErr>() == 4);

const _SIZE_CHECK_StreamErr: () = assert!(core::mem::size_of::<StreamErr>() == 20);
const _ALIGN_CHECK_StreamErr: () = assert!(core::mem::align_of::<StreamErr>() == 4);

impl StreamErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_StreamErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_StreamErr>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_StreamErr) {
        let discriminant_ptr: *mut discriminant_StreamErr = (self as *mut StreamErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct StreamErr {
    payload: union_StreamErr,
    discriminant: discriminant_StreamErr,
}

impl Clone for StreamErr {
    fn clone(&self) -> Self {
        use discriminant_StreamErr::*;

        let payload = unsafe {
            match self.discriminant {
                BrokenPipe => union_StreamErr {
                    BrokenPipe: self.payload.BrokenPipe.clone(),
                },
                ConnectionRefused => union_StreamErr {
                    ConnectionRefused: self.payload.ConnectionRefused.clone(),
                },
                ConnectionReset => union_StreamErr {
                    ConnectionReset: self.payload.ConnectionReset.clone(),
                },
                Interrupted => union_StreamErr {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                OutOfMemory => union_StreamErr {
                    OutOfMemory: self.payload.OutOfMemory.clone(),
                },
                PermissionDenied => union_StreamErr {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                Unrecognized => union_StreamErr {
                    Unrecognized: self.payload.Unrecognized.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for StreamErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_StreamErr::*;

        unsafe {
            match self.discriminant {
                BrokenPipe => {
                    let field: &() = &self.payload.BrokenPipe;
                    f.debug_tuple("StreamErr::BrokenPipe").field(field).finish()
                }
                ConnectionRefused => {
                    let field: &() = &self.payload.ConnectionRefused;
                    f.debug_tuple("StreamErr::ConnectionRefused")
                        .field(field)
                        .finish()
                }
                ConnectionReset => {
                    let field: &() = &self.payload.ConnectionReset;
                    f.debug_tuple("StreamErr::ConnectionReset")
                        .field(field)
                        .finish()
                }
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("StreamErr::Interrupted")
                        .field(field)
                        .finish()
                }
                OutOfMemory => {
                    let field: &() = &self.payload.OutOfMemory;
                    f.debug_tuple("StreamErr::OutOfMemory")
                        .field(field)
                        .finish()
                }
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("StreamErr::PermissionDenied")
                        .field(field)
                        .finish()
                }
                Unrecognized => {
                    let field: &ConnectErr_Unrecognized = &self.payload.Unrecognized;
                    f.debug_tuple("StreamErr::Unrecognized")
                        .field(field)
                        .finish()
                }
            }
        }
    }
}

impl Eq for StreamErr {}

impl PartialEq for StreamErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_StreamErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                BrokenPipe => self.payload.BrokenPipe == other.payload.BrokenPipe,
                ConnectionRefused => {
                    self.payload.ConnectionRefused == other.payload.ConnectionRefused
                }
                ConnectionReset => self.payload.ConnectionReset == other.payload.ConnectionReset,
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                OutOfMemory => self.payload.OutOfMemory == other.payload.OutOfMemory,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                Unrecognized => self.payload.Unrecognized == other.payload.Unrecognized,
            }
        }
    }
}

impl Ord for StreamErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for StreamErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_StreamErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    BrokenPipe => self
                        .payload
                        .BrokenPipe
                        .partial_cmp(&other.payload.BrokenPipe),
                    ConnectionRefused => self
                        .payload
                        .ConnectionRefused
                        .partial_cmp(&other.payload.ConnectionRefused),
                    ConnectionReset => self
                        .payload
                        .ConnectionReset
                        .partial_cmp(&other.payload.ConnectionReset),
                    Interrupted => self
                        .payload
                        .Interrupted
                        .partial_cmp(&other.payload.Interrupted),
                    OutOfMemory => self
                        .payload
                        .OutOfMemory
                        .partial_cmp(&other.payload.OutOfMemory),
                    PermissionDenied => self
                        .payload
                        .PermissionDenied
                        .partial_cmp(&other.payload.PermissionDenied),
                    Unrecognized => self
                        .payload
                        .Unrecognized
                        .partial_cmp(&other.payload.Unrecognized),
                }
            },
        }
    }
}

impl core::hash::Hash for StreamErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_StreamErr::*;

        unsafe {
            match self.discriminant {
                BrokenPipe => self.payload.BrokenPipe.hash(state),
                ConnectionRefused => self.payload.ConnectionRefused.hash(state),
                ConnectionReset => self.payload.ConnectionReset.hash(state),
                Interrupted => self.payload.Interrupted.hash(state),
                OutOfMemory => self.payload.OutOfMemory.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                Unrecognized => self.payload.Unrecognized.hash(state),
            }
        }
    }
}

impl StreamErr {
    pub fn is_BrokenPipe(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::BrokenPipe)
    }

    pub fn is_ConnectionRefused(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::ConnectionRefused)
    }

    pub fn is_ConnectionReset(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::ConnectionReset)
    }

    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::Interrupted)
    }

    pub fn is_OutOfMemory(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::OutOfMemory)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::PermissionDenied)
    }

    pub fn unwrap_Unrecognized(mut self) -> ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_StreamErr::Unrecognized);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unrecognized) }
    }

    pub fn borrow_Unrecognized(&self) -> &ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_StreamErr::Unrecognized);
        use core::borrow::Borrow;
        unsafe { self.payload.Unrecognized.borrow() }
    }

    pub fn borrow_mut_Unrecognized(&mut self) -> &mut ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_StreamErr::Unrecognized);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Unrecognized.borrow_mut() }
    }

    pub fn is_Unrecognized(&self) -> bool {
        matches!(self.discriminant, discriminant_StreamErr::Unrecognized)
    }
}

impl StreamErr {
    pub fn BrokenPipe() -> Self {
        Self {
            discriminant: discriminant_StreamErr::BrokenPipe,
            payload: union_StreamErr { BrokenPipe: () },
        }
    }

    pub fn ConnectionRefused() -> Self {
        Self {
            discriminant: discriminant_StreamErr::ConnectionRefused,
            payload: union_StreamErr {
                ConnectionRefused: (),
            },
        }
    }

    pub fn ConnectionReset() -> Self {
        Self {
            discriminant: discriminant_StreamErr::ConnectionReset,
            payload: union_StreamErr {
                ConnectionReset: (),
            },
        }
    }

    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_StreamErr::Interrupted,
            payload: union_StreamErr { Interrupted: () },
        }
    }

    pub fn OutOfMemory() -> Self {
        Self {
            discriminant: discriminant_StreamErr::OutOfMemory,
            payload: union_StreamErr { OutOfMemory: () },
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_StreamErr::PermissionDenied,
            payload: union_StreamErr {
                PermissionDenied: (),
            },
        }
    }

    pub fn Unrecognized(payload: ConnectErr_Unrecognized) -> Self {
        Self {
            discriminant: discriminant_StreamErr::Unrecognized,
            payload: union_StreamErr {
                Unrecognized: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for StreamErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_StreamErr::BrokenPipe => {}
            discriminant_StreamErr::ConnectionRefused => {}
            discriminant_StreamErr::ConnectionReset => {}
            discriminant_StreamErr::Interrupted => {}
            discriminant_StreamErr::OutOfMemory => {}
            discriminant_StreamErr::PermissionDenied => {}
            discriminant_StreamErr::Unrecognized => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Unrecognized)
            },
        }
    }
}

impl roc_std::RocRefcounted for StreamErr {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_ReadResult {
    Error = 0,
    Read = 1,
}

impl core::fmt::Debug for discriminant_ReadResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Error => f.write_str("discriminant_ReadResult::Error"),
            Self::Read => f.write_str("discriminant_ReadResult::Read"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_ReadResult);

#[repr(C, align(4))]
pub union union_ReadResult {
    Error: core::mem::ManuallyDrop<StreamErr>,
    Read: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
}

const _SIZE_CHECK_union_ReadResult: () = assert!(core::mem::size_of::<union_ReadResult>() == 20);
const _ALIGN_CHECK_union_ReadResult: () = assert!(core::mem::align_of::<union_ReadResult>() == 4);

const _SIZE_CHECK_ReadResult: () = assert!(core::mem::size_of::<ReadResult>() == 24);
const _ALIGN_CHECK_ReadResult: () = assert!(core::mem::align_of::<ReadResult>() == 4);

impl ReadResult {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ReadResult {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ReadResult>(*bytes.as_ptr().add(20))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ReadResult) {
        let discriminant_ptr: *mut discriminant_ReadResult = (self as *mut ReadResult).cast();

        unsafe {
            *(discriminant_ptr.add(20)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ReadResult {
    payload: union_ReadResult,
    discriminant: discriminant_ReadResult,
}

impl Clone for ReadResult {
    fn clone(&self) -> Self {
        use discriminant_ReadResult::*;

        let payload = unsafe {
            match self.discriminant {
                Error => union_ReadResult {
                    Error: self.payload.Error.clone(),
                },
                Read => union_ReadResult {
                    Read: self.payload.Read.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ReadResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ReadResult::*;

        unsafe {
            match self.discriminant {
                Error => {
                    let field: &StreamErr = &self.payload.Error;
                    f.debug_tuple("ReadResult::Error").field(field).finish()
                }
                Read => {
                    let field: &roc_std::RocList<u8> = &self.payload.Read;
                    f.debug_tuple("ReadResult::Read").field(field).finish()
                }
            }
        }
    }
}

impl Eq for ReadResult {}

impl PartialEq for ReadResult {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ReadResult::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Error => self.payload.Error == other.payload.Error,
                Read => self.payload.Read == other.payload.Read,
            }
        }
    }
}

impl Ord for ReadResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ReadResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ReadResult::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Error => self.payload.Error.partial_cmp(&other.payload.Error),
                    Read => self.payload.Read.partial_cmp(&other.payload.Read),
                }
            },
        }
    }
}

impl core::hash::Hash for ReadResult {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ReadResult::*;

        unsafe {
            match self.discriminant {
                Error => self.payload.Error.hash(state),
                Read => self.payload.Read.hash(state),
            }
        }
    }
}

impl ReadResult {
    pub fn unwrap_Error(mut self) -> StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_ReadResult::Error);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Error) }
    }

    pub fn borrow_Error(&self) -> &StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_ReadResult::Error);
        use core::borrow::Borrow;
        unsafe { self.payload.Error.borrow() }
    }

    pub fn borrow_mut_Error(&mut self) -> &mut StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_ReadResult::Error);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Error.borrow_mut() }
    }

    pub fn is_Error(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadResult::Error)
    }

    pub fn unwrap_Read(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_ReadResult::Read);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Read) }
    }

    pub fn borrow_Read(&self) -> &roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_ReadResult::Read);
        use core::borrow::Borrow;
        unsafe { self.payload.Read.borrow() }
    }

    pub fn borrow_mut_Read(&mut self) -> &mut roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_ReadResult::Read);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Read.borrow_mut() }
    }

    pub fn is_Read(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadResult::Read)
    }
}

impl ReadResult {
    pub fn Error(payload: StreamErr) -> Self {
        Self {
            discriminant: discriminant_ReadResult::Error,
            payload: union_ReadResult {
                Error: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Read(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_ReadResult::Read,
            payload: union_ReadResult {
                Read: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for ReadResult {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ReadResult::Error => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Error)
            },
            discriminant_ReadResult::Read => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Read)
            },
        }
    }
}

impl roc_std::RocRefcounted for ReadResult {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_ReadExactlyResult {
    Error = 0,
    Read = 1,
    UnexpectedEOF = 2,
}

impl core::fmt::Debug for discriminant_ReadExactlyResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Error => f.write_str("discriminant_ReadExactlyResult::Error"),
            Self::Read => f.write_str("discriminant_ReadExactlyResult::Read"),
            Self::UnexpectedEOF => f.write_str("discriminant_ReadExactlyResult::UnexpectedEOF"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_ReadExactlyResult);

#[repr(C, align(4))]
pub union union_ReadExactlyResult {
    Error: core::mem::ManuallyDrop<StreamErr>,
    Read: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    UnexpectedEOF: (),
}

const _SIZE_CHECK_union_ReadExactlyResult: () =
    assert!(core::mem::size_of::<union_ReadExactlyResult>() == 20);
const _ALIGN_CHECK_union_ReadExactlyResult: () =
    assert!(core::mem::align_of::<union_ReadExactlyResult>() == 4);

const _SIZE_CHECK_ReadExactlyResult: () = assert!(core::mem::size_of::<ReadExactlyResult>() == 24);
const _ALIGN_CHECK_ReadExactlyResult: () = assert!(core::mem::align_of::<ReadExactlyResult>() == 4);

impl ReadExactlyResult {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ReadExactlyResult {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ReadExactlyResult>(*bytes.as_ptr().add(20))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ReadExactlyResult) {
        let discriminant_ptr: *mut discriminant_ReadExactlyResult =
            (self as *mut ReadExactlyResult).cast();

        unsafe {
            *(discriminant_ptr.add(20)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ReadExactlyResult {
    payload: union_ReadExactlyResult,
    discriminant: discriminant_ReadExactlyResult,
}

impl Clone for ReadExactlyResult {
    fn clone(&self) -> Self {
        use discriminant_ReadExactlyResult::*;

        let payload = unsafe {
            match self.discriminant {
                Error => union_ReadExactlyResult {
                    Error: self.payload.Error.clone(),
                },
                Read => union_ReadExactlyResult {
                    Read: self.payload.Read.clone(),
                },
                UnexpectedEOF => union_ReadExactlyResult {
                    UnexpectedEOF: self.payload.UnexpectedEOF.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ReadExactlyResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ReadExactlyResult::*;

        unsafe {
            match self.discriminant {
                Error => {
                    let field: &StreamErr = &self.payload.Error;
                    f.debug_tuple("ReadExactlyResult::Error")
                        .field(field)
                        .finish()
                }
                Read => {
                    let field: &roc_std::RocList<u8> = &self.payload.Read;
                    f.debug_tuple("ReadExactlyResult::Read")
                        .field(field)
                        .finish()
                }
                UnexpectedEOF => {
                    let field: &() = &self.payload.UnexpectedEOF;
                    f.debug_tuple("ReadExactlyResult::UnexpectedEOF")
                        .field(field)
                        .finish()
                }
            }
        }
    }
}

impl Eq for ReadExactlyResult {}

impl PartialEq for ReadExactlyResult {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ReadExactlyResult::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Error => self.payload.Error == other.payload.Error,
                Read => self.payload.Read == other.payload.Read,
                UnexpectedEOF => self.payload.UnexpectedEOF == other.payload.UnexpectedEOF,
            }
        }
    }
}

impl Ord for ReadExactlyResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ReadExactlyResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ReadExactlyResult::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Error => self.payload.Error.partial_cmp(&other.payload.Error),
                    Read => self.payload.Read.partial_cmp(&other.payload.Read),
                    UnexpectedEOF => self
                        .payload
                        .UnexpectedEOF
                        .partial_cmp(&other.payload.UnexpectedEOF),
                }
            },
        }
    }
}

impl core::hash::Hash for ReadExactlyResult {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ReadExactlyResult::*;

        unsafe {
            match self.discriminant {
                Error => self.payload.Error.hash(state),
                Read => self.payload.Read.hash(state),
                UnexpectedEOF => self.payload.UnexpectedEOF.hash(state),
            }
        }
    }
}

impl ReadExactlyResult {
    pub fn unwrap_Error(mut self) -> StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_ReadExactlyResult::Error);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Error) }
    }

    pub fn borrow_Error(&self) -> &StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_ReadExactlyResult::Error);
        use core::borrow::Borrow;
        unsafe { self.payload.Error.borrow() }
    }

    pub fn borrow_mut_Error(&mut self) -> &mut StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_ReadExactlyResult::Error);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Error.borrow_mut() }
    }

    pub fn is_Error(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadExactlyResult::Error)
    }

    pub fn unwrap_Read(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_ReadExactlyResult::Read);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Read) }
    }

    pub fn borrow_Read(&self) -> &roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_ReadExactlyResult::Read);
        use core::borrow::Borrow;
        unsafe { self.payload.Read.borrow() }
    }

    pub fn borrow_mut_Read(&mut self) -> &mut roc_std::RocList<u8> {
        debug_assert_eq!(self.discriminant, discriminant_ReadExactlyResult::Read);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Read.borrow_mut() }
    }

    pub fn is_Read(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadExactlyResult::Read)
    }

    pub fn is_UnexpectedEOF(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_ReadExactlyResult::UnexpectedEOF
        )
    }
}

impl ReadExactlyResult {
    pub fn Error(payload: StreamErr) -> Self {
        Self {
            discriminant: discriminant_ReadExactlyResult::Error,
            payload: union_ReadExactlyResult {
                Error: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Read(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_ReadExactlyResult::Read,
            payload: union_ReadExactlyResult {
                Read: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn UnexpectedEOF() -> Self {
        Self {
            discriminant: discriminant_ReadExactlyResult::UnexpectedEOF,
            payload: union_ReadExactlyResult { UnexpectedEOF: () },
        }
    }
}

impl Drop for ReadExactlyResult {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ReadExactlyResult::Error => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Error)
            },
            discriminant_ReadExactlyResult::Read => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Read)
            },
            discriminant_ReadExactlyResult::UnexpectedEOF => {}
        }
    }
}

impl roc_std::RocRefcounted for ReadExactlyResult {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_WriteResult {
    Error = 0,
    Wrote = 1,
}

impl core::fmt::Debug for discriminant_WriteResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Error => f.write_str("discriminant_WriteResult::Error"),
            Self::Wrote => f.write_str("discriminant_WriteResult::Wrote"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_WriteResult);

#[repr(C, align(4))]
pub union union_WriteResult {
    Error: core::mem::ManuallyDrop<StreamErr>,
    Wrote: (),
}

const _SIZE_CHECK_union_WriteResult: () = assert!(core::mem::size_of::<union_WriteResult>() == 20);
const _ALIGN_CHECK_union_WriteResult: () = assert!(core::mem::align_of::<union_WriteResult>() == 4);

const _SIZE_CHECK_WriteResult: () = assert!(core::mem::size_of::<WriteResult>() == 24);
const _ALIGN_CHECK_WriteResult: () = assert!(core::mem::align_of::<WriteResult>() == 4);

impl WriteResult {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_WriteResult {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_WriteResult>(*bytes.as_ptr().add(20))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_WriteResult) {
        let discriminant_ptr: *mut discriminant_WriteResult = (self as *mut WriteResult).cast();

        unsafe {
            *(discriminant_ptr.add(20)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct WriteResult {
    payload: union_WriteResult,
    discriminant: discriminant_WriteResult,
}

impl Clone for WriteResult {
    fn clone(&self) -> Self {
        use discriminant_WriteResult::*;

        let payload = unsafe {
            match self.discriminant {
                Error => union_WriteResult {
                    Error: self.payload.Error.clone(),
                },
                Wrote => union_WriteResult {
                    Wrote: self.payload.Wrote.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for WriteResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_WriteResult::*;

        unsafe {
            match self.discriminant {
                Error => {
                    let field: &StreamErr = &self.payload.Error;
                    f.debug_tuple("WriteResult::Error").field(field).finish()
                }
                Wrote => {
                    let field: &() = &self.payload.Wrote;
                    f.debug_tuple("WriteResult::Wrote").field(field).finish()
                }
            }
        }
    }
}

impl Eq for WriteResult {}

impl PartialEq for WriteResult {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_WriteResult::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Error => self.payload.Error == other.payload.Error,
                Wrote => self.payload.Wrote == other.payload.Wrote,
            }
        }
    }
}

impl Ord for WriteResult {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for WriteResult {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_WriteResult::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Error => self.payload.Error.partial_cmp(&other.payload.Error),
                    Wrote => self.payload.Wrote.partial_cmp(&other.payload.Wrote),
                }
            },
        }
    }
}

impl core::hash::Hash for WriteResult {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_WriteResult::*;

        unsafe {
            match self.discriminant {
                Error => self.payload.Error.hash(state),
                Wrote => self.payload.Wrote.hash(state),
            }
        }
    }
}

impl WriteResult {
    pub fn unwrap_Error(mut self) -> StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_WriteResult::Error);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Error) }
    }

    pub fn borrow_Error(&self) -> &StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_WriteResult::Error);
        use core::borrow::Borrow;
        unsafe { self.payload.Error.borrow() }
    }

    pub fn borrow_mut_Error(&mut self) -> &mut StreamErr {
        debug_assert_eq!(self.discriminant, discriminant_WriteResult::Error);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Error.borrow_mut() }
    }

    pub fn is_Error(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteResult::Error)
    }

    pub fn is_Wrote(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteResult::Wrote)
    }
}

impl WriteResult {
    pub fn Error(payload: StreamErr) -> Self {
        Self {
            discriminant: discriminant_WriteResult::Error,
            payload: union_WriteResult {
                Error: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Wrote() -> Self {
        Self {
            discriminant: discriminant_WriteResult::Wrote,
            payload: union_WriteResult { Wrote: () },
        }
    }
}

impl Drop for WriteResult {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_WriteResult::Error => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Error)
            },
            discriminant_WriteResult::Wrote => {}
        }
    }
}

impl roc_std::RocRefcounted for WriteResult {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_UnwrappedPath {
    ArbitraryBytes = 0,
    FromOperatingSystem = 1,
    FromStr = 2,
}

impl core::fmt::Debug for discriminant_UnwrappedPath {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ArbitraryBytes => f.write_str("discriminant_UnwrappedPath::ArbitraryBytes"),
            Self::FromOperatingSystem => {
                f.write_str("discriminant_UnwrappedPath::FromOperatingSystem")
            }
            Self::FromStr => f.write_str("discriminant_UnwrappedPath::FromStr"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_UnwrappedPath);

#[repr(C, align(4))]
pub union union_UnwrappedPath {
    ArbitraryBytes: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    FromOperatingSystem: core::mem::ManuallyDrop<roc_std::RocList<u8>>,
    FromStr: core::mem::ManuallyDrop<roc_std::RocStr>,
}

const _SIZE_CHECK_union_UnwrappedPath: () =
    assert!(core::mem::size_of::<union_UnwrappedPath>() == 12);
const _ALIGN_CHECK_union_UnwrappedPath: () =
    assert!(core::mem::align_of::<union_UnwrappedPath>() == 4);

const _SIZE_CHECK_UnwrappedPath: () = assert!(core::mem::size_of::<UnwrappedPath>() == 16);
const _ALIGN_CHECK_UnwrappedPath: () = assert!(core::mem::align_of::<UnwrappedPath>() == 4);

impl UnwrappedPath {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_UnwrappedPath {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_UnwrappedPath>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_UnwrappedPath) {
        let discriminant_ptr: *mut discriminant_UnwrappedPath = (self as *mut UnwrappedPath).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct UnwrappedPath {
    payload: union_UnwrappedPath,
    discriminant: discriminant_UnwrappedPath,
}

impl Clone for UnwrappedPath {
    fn clone(&self) -> Self {
        use discriminant_UnwrappedPath::*;

        let payload = unsafe {
            match self.discriminant {
                ArbitraryBytes => union_UnwrappedPath {
                    ArbitraryBytes: self.payload.ArbitraryBytes.clone(),
                },
                FromOperatingSystem => union_UnwrappedPath {
                    FromOperatingSystem: self.payload.FromOperatingSystem.clone(),
                },
                FromStr => union_UnwrappedPath {
                    FromStr: self.payload.FromStr.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for UnwrappedPath {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_UnwrappedPath::*;

        unsafe {
            match self.discriminant {
                ArbitraryBytes => {
                    let field: &roc_std::RocList<u8> = &self.payload.ArbitraryBytes;
                    f.debug_tuple("UnwrappedPath::ArbitraryBytes")
                        .field(field)
                        .finish()
                }
                FromOperatingSystem => {
                    let field: &roc_std::RocList<u8> = &self.payload.FromOperatingSystem;
                    f.debug_tuple("UnwrappedPath::FromOperatingSystem")
                        .field(field)
                        .finish()
                }
                FromStr => {
                    let field: &roc_std::RocStr = &self.payload.FromStr;
                    f.debug_tuple("UnwrappedPath::FromStr")
                        .field(field)
                        .finish()
                }
            }
        }
    }
}

impl Eq for UnwrappedPath {}

impl PartialEq for UnwrappedPath {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_UnwrappedPath::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                ArbitraryBytes => self.payload.ArbitraryBytes == other.payload.ArbitraryBytes,
                FromOperatingSystem => {
                    self.payload.FromOperatingSystem == other.payload.FromOperatingSystem
                }
                FromStr => self.payload.FromStr == other.payload.FromStr,
            }
        }
    }
}

impl Ord for UnwrappedPath {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for UnwrappedPath {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_UnwrappedPath::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    ArbitraryBytes => self
                        .payload
                        .ArbitraryBytes
                        .partial_cmp(&other.payload.ArbitraryBytes),
                    FromOperatingSystem => self
                        .payload
                        .FromOperatingSystem
                        .partial_cmp(&other.payload.FromOperatingSystem),
                    FromStr => self.payload.FromStr.partial_cmp(&other.payload.FromStr),
                }
            },
        }
    }
}

impl core::hash::Hash for UnwrappedPath {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_UnwrappedPath::*;

        unsafe {
            match self.discriminant {
                ArbitraryBytes => self.payload.ArbitraryBytes.hash(state),
                FromOperatingSystem => self.payload.FromOperatingSystem.hash(state),
                FromStr => self.payload.FromStr.hash(state),
            }
        }
    }
}

impl UnwrappedPath {
    pub fn unwrap_ArbitraryBytes(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(
            self.discriminant,
            discriminant_UnwrappedPath::ArbitraryBytes
        );
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.ArbitraryBytes) }
    }

    pub fn borrow_ArbitraryBytes(&self) -> &roc_std::RocList<u8> {
        debug_assert_eq!(
            self.discriminant,
            discriminant_UnwrappedPath::ArbitraryBytes
        );
        use core::borrow::Borrow;
        unsafe { self.payload.ArbitraryBytes.borrow() }
    }

    pub fn borrow_mut_ArbitraryBytes(&mut self) -> &mut roc_std::RocList<u8> {
        debug_assert_eq!(
            self.discriminant,
            discriminant_UnwrappedPath::ArbitraryBytes
        );
        use core::borrow::BorrowMut;
        unsafe { self.payload.ArbitraryBytes.borrow_mut() }
    }

    pub fn is_ArbitraryBytes(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_UnwrappedPath::ArbitraryBytes
        )
    }

    pub fn unwrap_FromOperatingSystem(mut self) -> roc_std::RocList<u8> {
        debug_assert_eq!(
            self.discriminant,
            discriminant_UnwrappedPath::FromOperatingSystem
        );
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.FromOperatingSystem) }
    }

    pub fn borrow_FromOperatingSystem(&self) -> &roc_std::RocList<u8> {
        debug_assert_eq!(
            self.discriminant,
            discriminant_UnwrappedPath::FromOperatingSystem
        );
        use core::borrow::Borrow;
        unsafe { self.payload.FromOperatingSystem.borrow() }
    }

    pub fn borrow_mut_FromOperatingSystem(&mut self) -> &mut roc_std::RocList<u8> {
        debug_assert_eq!(
            self.discriminant,
            discriminant_UnwrappedPath::FromOperatingSystem
        );
        use core::borrow::BorrowMut;
        unsafe { self.payload.FromOperatingSystem.borrow_mut() }
    }

    pub fn is_FromOperatingSystem(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_UnwrappedPath::FromOperatingSystem
        )
    }

    pub fn unwrap_FromStr(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_UnwrappedPath::FromStr);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.FromStr) }
    }

    pub fn borrow_FromStr(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_UnwrappedPath::FromStr);
        use core::borrow::Borrow;
        unsafe { self.payload.FromStr.borrow() }
    }

    pub fn borrow_mut_FromStr(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_UnwrappedPath::FromStr);
        use core::borrow::BorrowMut;
        unsafe { self.payload.FromStr.borrow_mut() }
    }

    pub fn is_FromStr(&self) -> bool {
        matches!(self.discriminant, discriminant_UnwrappedPath::FromStr)
    }
}

impl UnwrappedPath {
    pub fn ArbitraryBytes(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_UnwrappedPath::ArbitraryBytes,
            payload: union_UnwrappedPath {
                ArbitraryBytes: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn FromOperatingSystem(payload: roc_std::RocList<u8>) -> Self {
        Self {
            discriminant: discriminant_UnwrappedPath::FromOperatingSystem,
            payload: union_UnwrappedPath {
                FromOperatingSystem: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn FromStr(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_UnwrappedPath::FromStr,
            payload: union_UnwrappedPath {
                FromStr: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for UnwrappedPath {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_UnwrappedPath::ArbitraryBytes => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.ArbitraryBytes)
            },
            discriminant_UnwrappedPath::FromOperatingSystem => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.FromOperatingSystem)
            },
            discriminant_UnwrappedPath::FromStr => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.FromStr)
            },
        }
    }
}

impl roc_std::RocRefcounted for UnwrappedPath {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct InternalDirReadErr {
    f0: UnwrappedPath,
    f1: roc_std::RocStr,
}

impl InternalDirReadErr {
    /// A tag named ``DirReadErr``, with the given payload.
    pub fn DirReadErr(f0: UnwrappedPath, f1: roc_std::RocStr) -> Self {
        Self { f0, f1 }
    }

    /// Since `InternalDirReadErr` only has one tag (namely, `DirReadErr`),
    /// convert it to `DirReadErr`'s payload.
    pub fn into_DirReadErr(self) -> (UnwrappedPath, roc_std::RocStr) {
        (self.f0, self.f1)
    }

    /// Since `InternalDirReadErr` only has one tag (namely, `DirReadErr`),
    /// convert it to `DirReadErr`'s payload.
    pub fn as_DirReadErr(&self) -> (&UnwrappedPath, &roc_std::RocStr) {
        (&self.f0, &self.f1)
    }
}

impl core::fmt::Debug for InternalDirReadErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_tuple("InternalDirReadErr::DirReadErr")
            .field(&self.f0)
            .field(&self.f1)
            .finish()
    }
}

impl roc_std::RocRefcounted for InternalDirReadErr {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_ReadErr {
    Interrupted = 0,
    InvalidFilename = 1,
    NotFound = 2,
    OutOfMemory = 3,
    PermissionDenied = 4,
    StaleNetworkFileHandle = 5,
    TimedOut = 6,
    TooManyHardlinks = 7,
    TooManySymlinks = 8,
    Unrecognized = 9,
    Unsupported = 10,
}

impl core::fmt::Debug for discriminant_ReadErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Interrupted => f.write_str("discriminant_ReadErr::Interrupted"),
            Self::InvalidFilename => f.write_str("discriminant_ReadErr::InvalidFilename"),
            Self::NotFound => f.write_str("discriminant_ReadErr::NotFound"),
            Self::OutOfMemory => f.write_str("discriminant_ReadErr::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_ReadErr::PermissionDenied"),
            Self::StaleNetworkFileHandle => {
                f.write_str("discriminant_ReadErr::StaleNetworkFileHandle")
            }
            Self::TimedOut => f.write_str("discriminant_ReadErr::TimedOut"),
            Self::TooManyHardlinks => f.write_str("discriminant_ReadErr::TooManyHardlinks"),
            Self::TooManySymlinks => f.write_str("discriminant_ReadErr::TooManySymlinks"),
            Self::Unrecognized => f.write_str("discriminant_ReadErr::Unrecognized"),
            Self::Unsupported => f.write_str("discriminant_ReadErr::Unsupported"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_ReadErr);

#[repr(C, align(4))]
pub union union_ReadErr {
    Interrupted: (),
    InvalidFilename: (),
    NotFound: (),
    OutOfMemory: (),
    PermissionDenied: (),
    StaleNetworkFileHandle: (),
    TimedOut: (),
    TooManyHardlinks: (),
    TooManySymlinks: (),
    Unrecognized: core::mem::ManuallyDrop<ConnectErr_Unrecognized>,
    Unsupported: (),
}

// const _SIZE_CHECK_union_ReadErr: () = assert!(core::mem::size_of::<union_ReadErr>() == 20);
const _ALIGN_CHECK_union_ReadErr: () = assert!(core::mem::align_of::<union_ReadErr>() == 4);

const _SIZE_CHECK_ReadErr: () = assert!(core::mem::size_of::<ReadErr>() == 20);
const _ALIGN_CHECK_ReadErr: () = assert!(core::mem::align_of::<ReadErr>() == 4);

impl ReadErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ReadErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ReadErr>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ReadErr) {
        let discriminant_ptr: *mut discriminant_ReadErr = (self as *mut ReadErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct ReadErr {
    payload: union_ReadErr,
    discriminant: discriminant_ReadErr,
}

impl Clone for ReadErr {
    fn clone(&self) -> Self {
        use discriminant_ReadErr::*;

        let payload = unsafe {
            match self.discriminant {
                Interrupted => union_ReadErr {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                InvalidFilename => union_ReadErr {
                    InvalidFilename: self.payload.InvalidFilename.clone(),
                },
                NotFound => union_ReadErr {
                    NotFound: self.payload.NotFound.clone(),
                },
                OutOfMemory => union_ReadErr {
                    OutOfMemory: self.payload.OutOfMemory.clone(),
                },
                PermissionDenied => union_ReadErr {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                StaleNetworkFileHandle => union_ReadErr {
                    StaleNetworkFileHandle: self.payload.StaleNetworkFileHandle.clone(),
                },
                TimedOut => union_ReadErr {
                    TimedOut: self.payload.TimedOut.clone(),
                },
                TooManyHardlinks => union_ReadErr {
                    TooManyHardlinks: self.payload.TooManyHardlinks.clone(),
                },
                TooManySymlinks => union_ReadErr {
                    TooManySymlinks: self.payload.TooManySymlinks.clone(),
                },
                Unrecognized => union_ReadErr {
                    Unrecognized: self.payload.Unrecognized.clone(),
                },
                Unsupported => union_ReadErr {
                    Unsupported: self.payload.Unsupported.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for ReadErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_ReadErr::*;

        unsafe {
            match self.discriminant {
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("ReadErr::Interrupted").field(field).finish()
                }
                InvalidFilename => {
                    let field: &() = &self.payload.InvalidFilename;
                    f.debug_tuple("ReadErr::InvalidFilename")
                        .field(field)
                        .finish()
                }
                NotFound => {
                    let field: &() = &self.payload.NotFound;
                    f.debug_tuple("ReadErr::NotFound").field(field).finish()
                }
                OutOfMemory => {
                    let field: &() = &self.payload.OutOfMemory;
                    f.debug_tuple("ReadErr::OutOfMemory").field(field).finish()
                }
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("ReadErr::PermissionDenied")
                        .field(field)
                        .finish()
                }
                StaleNetworkFileHandle => {
                    let field: &() = &self.payload.StaleNetworkFileHandle;
                    f.debug_tuple("ReadErr::StaleNetworkFileHandle")
                        .field(field)
                        .finish()
                }
                TimedOut => {
                    let field: &() = &self.payload.TimedOut;
                    f.debug_tuple("ReadErr::TimedOut").field(field).finish()
                }
                TooManyHardlinks => {
                    let field: &() = &self.payload.TooManyHardlinks;
                    f.debug_tuple("ReadErr::TooManyHardlinks")
                        .field(field)
                        .finish()
                }
                TooManySymlinks => {
                    let field: &() = &self.payload.TooManySymlinks;
                    f.debug_tuple("ReadErr::TooManySymlinks")
                        .field(field)
                        .finish()
                }
                Unrecognized => {
                    let field: &ConnectErr_Unrecognized = &self.payload.Unrecognized;
                    f.debug_tuple("ReadErr::Unrecognized").field(field).finish()
                }
                Unsupported => {
                    let field: &() = &self.payload.Unsupported;
                    f.debug_tuple("ReadErr::Unsupported").field(field).finish()
                }
            }
        }
    }
}

impl Eq for ReadErr {}

impl PartialEq for ReadErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_ReadErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                InvalidFilename => self.payload.InvalidFilename == other.payload.InvalidFilename,
                NotFound => self.payload.NotFound == other.payload.NotFound,
                OutOfMemory => self.payload.OutOfMemory == other.payload.OutOfMemory,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                StaleNetworkFileHandle => {
                    self.payload.StaleNetworkFileHandle == other.payload.StaleNetworkFileHandle
                }
                TimedOut => self.payload.TimedOut == other.payload.TimedOut,
                TooManyHardlinks => self.payload.TooManyHardlinks == other.payload.TooManyHardlinks,
                TooManySymlinks => self.payload.TooManySymlinks == other.payload.TooManySymlinks,
                Unrecognized => self.payload.Unrecognized == other.payload.Unrecognized,
                Unsupported => self.payload.Unsupported == other.payload.Unsupported,
            }
        }
    }
}

impl Ord for ReadErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for ReadErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_ReadErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Interrupted => self
                        .payload
                        .Interrupted
                        .partial_cmp(&other.payload.Interrupted),
                    InvalidFilename => self
                        .payload
                        .InvalidFilename
                        .partial_cmp(&other.payload.InvalidFilename),
                    NotFound => self.payload.NotFound.partial_cmp(&other.payload.NotFound),
                    OutOfMemory => self
                        .payload
                        .OutOfMemory
                        .partial_cmp(&other.payload.OutOfMemory),
                    PermissionDenied => self
                        .payload
                        .PermissionDenied
                        .partial_cmp(&other.payload.PermissionDenied),
                    StaleNetworkFileHandle => self
                        .payload
                        .StaleNetworkFileHandle
                        .partial_cmp(&other.payload.StaleNetworkFileHandle),
                    TimedOut => self.payload.TimedOut.partial_cmp(&other.payload.TimedOut),
                    TooManyHardlinks => self
                        .payload
                        .TooManyHardlinks
                        .partial_cmp(&other.payload.TooManyHardlinks),
                    TooManySymlinks => self
                        .payload
                        .TooManySymlinks
                        .partial_cmp(&other.payload.TooManySymlinks),
                    Unrecognized => self
                        .payload
                        .Unrecognized
                        .partial_cmp(&other.payload.Unrecognized),
                    Unsupported => self
                        .payload
                        .Unsupported
                        .partial_cmp(&other.payload.Unsupported),
                }
            },
        }
    }
}

impl core::hash::Hash for ReadErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_ReadErr::*;

        unsafe {
            match self.discriminant {
                Interrupted => self.payload.Interrupted.hash(state),
                InvalidFilename => self.payload.InvalidFilename.hash(state),
                NotFound => self.payload.NotFound.hash(state),
                OutOfMemory => self.payload.OutOfMemory.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle.hash(state),
                TimedOut => self.payload.TimedOut.hash(state),
                TooManyHardlinks => self.payload.TooManyHardlinks.hash(state),
                TooManySymlinks => self.payload.TooManySymlinks.hash(state),
                Unrecognized => self.payload.Unrecognized.hash(state),
                Unsupported => self.payload.Unsupported.hash(state),
            }
        }
    }
}

impl ReadErr {
    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::Interrupted)
    }

    pub fn is_InvalidFilename(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::InvalidFilename)
    }

    pub fn is_NotFound(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::NotFound)
    }

    pub fn is_OutOfMemory(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::OutOfMemory)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::PermissionDenied)
    }

    pub fn is_StaleNetworkFileHandle(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_ReadErr::StaleNetworkFileHandle
        )
    }

    pub fn is_TimedOut(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::TimedOut)
    }

    pub fn is_TooManyHardlinks(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::TooManyHardlinks)
    }

    pub fn is_TooManySymlinks(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::TooManySymlinks)
    }

    pub fn unwrap_Unrecognized(mut self) -> ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_ReadErr::Unrecognized);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unrecognized) }
    }

    pub fn borrow_Unrecognized(&self) -> &ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_ReadErr::Unrecognized);
        use core::borrow::Borrow;
        unsafe { self.payload.Unrecognized.borrow() }
    }

    pub fn borrow_mut_Unrecognized(&mut self) -> &mut ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_ReadErr::Unrecognized);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Unrecognized.borrow_mut() }
    }

    pub fn is_Unrecognized(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::Unrecognized)
    }

    pub fn is_Unsupported(&self) -> bool {
        matches!(self.discriminant, discriminant_ReadErr::Unsupported)
    }
}

impl ReadErr {
    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_ReadErr::Interrupted,
            payload: union_ReadErr { Interrupted: () },
        }
    }

    pub fn InvalidFilename() -> Self {
        Self {
            discriminant: discriminant_ReadErr::InvalidFilename,
            payload: union_ReadErr {
                InvalidFilename: (),
            },
        }
    }

    pub fn NotFound() -> Self {
        Self {
            discriminant: discriminant_ReadErr::NotFound,
            payload: union_ReadErr { NotFound: () },
        }
    }

    pub fn OutOfMemory() -> Self {
        Self {
            discriminant: discriminant_ReadErr::OutOfMemory,
            payload: union_ReadErr { OutOfMemory: () },
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_ReadErr::PermissionDenied,
            payload: union_ReadErr {
                PermissionDenied: (),
            },
        }
    }

    pub fn StaleNetworkFileHandle() -> Self {
        Self {
            discriminant: discriminant_ReadErr::StaleNetworkFileHandle,
            payload: union_ReadErr {
                StaleNetworkFileHandle: (),
            },
        }
    }

    pub fn TimedOut() -> Self {
        Self {
            discriminant: discriminant_ReadErr::TimedOut,
            payload: union_ReadErr { TimedOut: () },
        }
    }

    pub fn TooManyHardlinks() -> Self {
        Self {
            discriminant: discriminant_ReadErr::TooManyHardlinks,
            payload: union_ReadErr {
                TooManyHardlinks: (),
            },
        }
    }

    pub fn TooManySymlinks() -> Self {
        Self {
            discriminant: discriminant_ReadErr::TooManySymlinks,
            payload: union_ReadErr {
                TooManySymlinks: (),
            },
        }
    }

    pub fn Unrecognized(payload: ConnectErr_Unrecognized) -> Self {
        Self {
            discriminant: discriminant_ReadErr::Unrecognized,
            payload: union_ReadErr {
                Unrecognized: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Unsupported() -> Self {
        Self {
            discriminant: discriminant_ReadErr::Unsupported,
            payload: union_ReadErr { Unsupported: () },
        }
    }
}

impl Drop for ReadErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ReadErr::Interrupted => {}
            discriminant_ReadErr::InvalidFilename => {}
            discriminant_ReadErr::NotFound => {}
            discriminant_ReadErr::OutOfMemory => {}
            discriminant_ReadErr::PermissionDenied => {}
            discriminant_ReadErr::StaleNetworkFileHandle => {}
            discriminant_ReadErr::TimedOut => {}
            discriminant_ReadErr::TooManyHardlinks => {}
            discriminant_ReadErr::TooManySymlinks => {}
            discriminant_ReadErr::Unrecognized => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Unrecognized)
            },
            discriminant_ReadErr::Unsupported => {}
        }
    }
}

impl roc_std::RocRefcounted for ReadErr {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_WriteErr {
    AlreadyExists = 0,
    ExecutableFileBusy = 1,
    FileTooLarge = 2,
    FilesystemQuotaExceeded = 3,
    Interrupted = 4,
    InvalidFilename = 5,
    NotFound = 6,
    OutOfMemory = 7,
    PermissionDenied = 8,
    ReadOnlyFilesystem = 9,
    ResourceBusy = 10,
    StaleNetworkFileHandle = 11,
    StorageFull = 12,
    TimedOut = 13,
    TooManyHardlinks = 14,
    TooManySymlinks = 15,
    Unrecognized = 16,
    Unsupported = 17,
    WasADirectory = 18,
    WriteZero = 19,
}

impl core::fmt::Debug for discriminant_WriteErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::AlreadyExists => f.write_str("discriminant_WriteErr::AlreadyExists"),
            Self::ExecutableFileBusy => f.write_str("discriminant_WriteErr::ExecutableFileBusy"),
            Self::FileTooLarge => f.write_str("discriminant_WriteErr::FileTooLarge"),
            Self::FilesystemQuotaExceeded => {
                f.write_str("discriminant_WriteErr::FilesystemQuotaExceeded")
            }
            Self::Interrupted => f.write_str("discriminant_WriteErr::Interrupted"),
            Self::InvalidFilename => f.write_str("discriminant_WriteErr::InvalidFilename"),
            Self::NotFound => f.write_str("discriminant_WriteErr::NotFound"),
            Self::OutOfMemory => f.write_str("discriminant_WriteErr::OutOfMemory"),
            Self::PermissionDenied => f.write_str("discriminant_WriteErr::PermissionDenied"),
            Self::ReadOnlyFilesystem => f.write_str("discriminant_WriteErr::ReadOnlyFilesystem"),
            Self::ResourceBusy => f.write_str("discriminant_WriteErr::ResourceBusy"),
            Self::StaleNetworkFileHandle => {
                f.write_str("discriminant_WriteErr::StaleNetworkFileHandle")
            }
            Self::StorageFull => f.write_str("discriminant_WriteErr::StorageFull"),
            Self::TimedOut => f.write_str("discriminant_WriteErr::TimedOut"),
            Self::TooManyHardlinks => f.write_str("discriminant_WriteErr::TooManyHardlinks"),
            Self::TooManySymlinks => f.write_str("discriminant_WriteErr::TooManySymlinks"),
            Self::Unrecognized => f.write_str("discriminant_WriteErr::Unrecognized"),
            Self::Unsupported => f.write_str("discriminant_WriteErr::Unsupported"),
            Self::WasADirectory => f.write_str("discriminant_WriteErr::WasADirectory"),
            Self::WriteZero => f.write_str("discriminant_WriteErr::WriteZero"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_WriteErr);

#[repr(C, align(4))]
pub union union_WriteErr {
    AlreadyExists: (),
    ExecutableFileBusy: (),
    FileTooLarge: (),
    FilesystemQuotaExceeded: (),
    Interrupted: (),
    InvalidFilename: (),
    NotFound: (),
    OutOfMemory: (),
    PermissionDenied: (),
    ReadOnlyFilesystem: (),
    ResourceBusy: (),
    StaleNetworkFileHandle: (),
    StorageFull: (),
    TimedOut: (),
    TooManyHardlinks: (),
    TooManySymlinks: (),
    Unrecognized: core::mem::ManuallyDrop<ConnectErr_Unrecognized>,
    Unsupported: (),
    WasADirectory: (),
    WriteZero: (),
}

// const _SIZE_CHECK_union_WriteErr: () = assert!(core::mem::size_of::<union_WriteErr>() == 20);
const _ALIGN_CHECK_union_WriteErr: () = assert!(core::mem::align_of::<union_WriteErr>() == 4);

const _SIZE_CHECK_WriteErr: () = assert!(core::mem::size_of::<WriteErr>() == 20);
const _ALIGN_CHECK_WriteErr: () = assert!(core::mem::align_of::<WriteErr>() == 4);

impl WriteErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_WriteErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_WriteErr>(*bytes.as_ptr().add(16))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_WriteErr) {
        let discriminant_ptr: *mut discriminant_WriteErr = (self as *mut WriteErr).cast();

        unsafe {
            *(discriminant_ptr.add(16)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct WriteErr {
    payload: union_WriteErr,
    discriminant: discriminant_WriteErr,
}

impl Clone for WriteErr {
    fn clone(&self) -> Self {
        use discriminant_WriteErr::*;

        let payload = unsafe {
            match self.discriminant {
                AlreadyExists => union_WriteErr {
                    AlreadyExists: self.payload.AlreadyExists.clone(),
                },
                ExecutableFileBusy => union_WriteErr {
                    ExecutableFileBusy: self.payload.ExecutableFileBusy.clone(),
                },
                FileTooLarge => union_WriteErr {
                    FileTooLarge: self.payload.FileTooLarge.clone(),
                },
                FilesystemQuotaExceeded => union_WriteErr {
                    FilesystemQuotaExceeded: self.payload.FilesystemQuotaExceeded.clone(),
                },
                Interrupted => union_WriteErr {
                    Interrupted: self.payload.Interrupted.clone(),
                },
                InvalidFilename => union_WriteErr {
                    InvalidFilename: self.payload.InvalidFilename.clone(),
                },
                NotFound => union_WriteErr {
                    NotFound: self.payload.NotFound.clone(),
                },
                OutOfMemory => union_WriteErr {
                    OutOfMemory: self.payload.OutOfMemory.clone(),
                },
                PermissionDenied => union_WriteErr {
                    PermissionDenied: self.payload.PermissionDenied.clone(),
                },
                ReadOnlyFilesystem => union_WriteErr {
                    ReadOnlyFilesystem: self.payload.ReadOnlyFilesystem.clone(),
                },
                ResourceBusy => union_WriteErr {
                    ResourceBusy: self.payload.ResourceBusy.clone(),
                },
                StaleNetworkFileHandle => union_WriteErr {
                    StaleNetworkFileHandle: self.payload.StaleNetworkFileHandle.clone(),
                },
                StorageFull => union_WriteErr {
                    StorageFull: self.payload.StorageFull.clone(),
                },
                TimedOut => union_WriteErr {
                    TimedOut: self.payload.TimedOut.clone(),
                },
                TooManyHardlinks => union_WriteErr {
                    TooManyHardlinks: self.payload.TooManyHardlinks.clone(),
                },
                TooManySymlinks => union_WriteErr {
                    TooManySymlinks: self.payload.TooManySymlinks.clone(),
                },
                Unrecognized => union_WriteErr {
                    Unrecognized: self.payload.Unrecognized.clone(),
                },
                Unsupported => union_WriteErr {
                    Unsupported: self.payload.Unsupported.clone(),
                },
                WasADirectory => union_WriteErr {
                    WasADirectory: self.payload.WasADirectory.clone(),
                },
                WriteZero => union_WriteErr {
                    WriteZero: self.payload.WriteZero.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for WriteErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_WriteErr::*;

        unsafe {
            match self.discriminant {
                AlreadyExists => {
                    let field: &() = &self.payload.AlreadyExists;
                    f.debug_tuple("WriteErr::AlreadyExists")
                        .field(field)
                        .finish()
                }
                ExecutableFileBusy => {
                    let field: &() = &self.payload.ExecutableFileBusy;
                    f.debug_tuple("WriteErr::ExecutableFileBusy")
                        .field(field)
                        .finish()
                }
                FileTooLarge => {
                    let field: &() = &self.payload.FileTooLarge;
                    f.debug_tuple("WriteErr::FileTooLarge")
                        .field(field)
                        .finish()
                }
                FilesystemQuotaExceeded => {
                    let field: &() = &self.payload.FilesystemQuotaExceeded;
                    f.debug_tuple("WriteErr::FilesystemQuotaExceeded")
                        .field(field)
                        .finish()
                }
                Interrupted => {
                    let field: &() = &self.payload.Interrupted;
                    f.debug_tuple("WriteErr::Interrupted").field(field).finish()
                }
                InvalidFilename => {
                    let field: &() = &self.payload.InvalidFilename;
                    f.debug_tuple("WriteErr::InvalidFilename")
                        .field(field)
                        .finish()
                }
                NotFound => {
                    let field: &() = &self.payload.NotFound;
                    f.debug_tuple("WriteErr::NotFound").field(field).finish()
                }
                OutOfMemory => {
                    let field: &() = &self.payload.OutOfMemory;
                    f.debug_tuple("WriteErr::OutOfMemory").field(field).finish()
                }
                PermissionDenied => {
                    let field: &() = &self.payload.PermissionDenied;
                    f.debug_tuple("WriteErr::PermissionDenied")
                        .field(field)
                        .finish()
                }
                ReadOnlyFilesystem => {
                    let field: &() = &self.payload.ReadOnlyFilesystem;
                    f.debug_tuple("WriteErr::ReadOnlyFilesystem")
                        .field(field)
                        .finish()
                }
                ResourceBusy => {
                    let field: &() = &self.payload.ResourceBusy;
                    f.debug_tuple("WriteErr::ResourceBusy")
                        .field(field)
                        .finish()
                }
                StaleNetworkFileHandle => {
                    let field: &() = &self.payload.StaleNetworkFileHandle;
                    f.debug_tuple("WriteErr::StaleNetworkFileHandle")
                        .field(field)
                        .finish()
                }
                StorageFull => {
                    let field: &() = &self.payload.StorageFull;
                    f.debug_tuple("WriteErr::StorageFull").field(field).finish()
                }
                TimedOut => {
                    let field: &() = &self.payload.TimedOut;
                    f.debug_tuple("WriteErr::TimedOut").field(field).finish()
                }
                TooManyHardlinks => {
                    let field: &() = &self.payload.TooManyHardlinks;
                    f.debug_tuple("WriteErr::TooManyHardlinks")
                        .field(field)
                        .finish()
                }
                TooManySymlinks => {
                    let field: &() = &self.payload.TooManySymlinks;
                    f.debug_tuple("WriteErr::TooManySymlinks")
                        .field(field)
                        .finish()
                }
                Unrecognized => {
                    let field: &ConnectErr_Unrecognized = &self.payload.Unrecognized;
                    f.debug_tuple("WriteErr::Unrecognized")
                        .field(field)
                        .finish()
                }
                Unsupported => {
                    let field: &() = &self.payload.Unsupported;
                    f.debug_tuple("WriteErr::Unsupported").field(field).finish()
                }
                WasADirectory => {
                    let field: &() = &self.payload.WasADirectory;
                    f.debug_tuple("WriteErr::WasADirectory")
                        .field(field)
                        .finish()
                }
                WriteZero => {
                    let field: &() = &self.payload.WriteZero;
                    f.debug_tuple("WriteErr::WriteZero").field(field).finish()
                }
            }
        }
    }
}

impl Eq for WriteErr {}

impl PartialEq for WriteErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_WriteErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                AlreadyExists => self.payload.AlreadyExists == other.payload.AlreadyExists,
                ExecutableFileBusy => {
                    self.payload.ExecutableFileBusy == other.payload.ExecutableFileBusy
                }
                FileTooLarge => self.payload.FileTooLarge == other.payload.FileTooLarge,
                FilesystemQuotaExceeded => {
                    self.payload.FilesystemQuotaExceeded == other.payload.FilesystemQuotaExceeded
                }
                Interrupted => self.payload.Interrupted == other.payload.Interrupted,
                InvalidFilename => self.payload.InvalidFilename == other.payload.InvalidFilename,
                NotFound => self.payload.NotFound == other.payload.NotFound,
                OutOfMemory => self.payload.OutOfMemory == other.payload.OutOfMemory,
                PermissionDenied => self.payload.PermissionDenied == other.payload.PermissionDenied,
                ReadOnlyFilesystem => {
                    self.payload.ReadOnlyFilesystem == other.payload.ReadOnlyFilesystem
                }
                ResourceBusy => self.payload.ResourceBusy == other.payload.ResourceBusy,
                StaleNetworkFileHandle => {
                    self.payload.StaleNetworkFileHandle == other.payload.StaleNetworkFileHandle
                }
                StorageFull => self.payload.StorageFull == other.payload.StorageFull,
                TimedOut => self.payload.TimedOut == other.payload.TimedOut,
                TooManyHardlinks => self.payload.TooManyHardlinks == other.payload.TooManyHardlinks,
                TooManySymlinks => self.payload.TooManySymlinks == other.payload.TooManySymlinks,
                Unrecognized => self.payload.Unrecognized == other.payload.Unrecognized,
                Unsupported => self.payload.Unsupported == other.payload.Unsupported,
                WasADirectory => self.payload.WasADirectory == other.payload.WasADirectory,
                WriteZero => self.payload.WriteZero == other.payload.WriteZero,
            }
        }
    }
}

impl Ord for WriteErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for WriteErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_WriteErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    AlreadyExists => self
                        .payload
                        .AlreadyExists
                        .partial_cmp(&other.payload.AlreadyExists),
                    ExecutableFileBusy => self
                        .payload
                        .ExecutableFileBusy
                        .partial_cmp(&other.payload.ExecutableFileBusy),
                    FileTooLarge => self
                        .payload
                        .FileTooLarge
                        .partial_cmp(&other.payload.FileTooLarge),
                    FilesystemQuotaExceeded => self
                        .payload
                        .FilesystemQuotaExceeded
                        .partial_cmp(&other.payload.FilesystemQuotaExceeded),
                    Interrupted => self
                        .payload
                        .Interrupted
                        .partial_cmp(&other.payload.Interrupted),
                    InvalidFilename => self
                        .payload
                        .InvalidFilename
                        .partial_cmp(&other.payload.InvalidFilename),
                    NotFound => self.payload.NotFound.partial_cmp(&other.payload.NotFound),
                    OutOfMemory => self
                        .payload
                        .OutOfMemory
                        .partial_cmp(&other.payload.OutOfMemory),
                    PermissionDenied => self
                        .payload
                        .PermissionDenied
                        .partial_cmp(&other.payload.PermissionDenied),
                    ReadOnlyFilesystem => self
                        .payload
                        .ReadOnlyFilesystem
                        .partial_cmp(&other.payload.ReadOnlyFilesystem),
                    ResourceBusy => self
                        .payload
                        .ResourceBusy
                        .partial_cmp(&other.payload.ResourceBusy),
                    StaleNetworkFileHandle => self
                        .payload
                        .StaleNetworkFileHandle
                        .partial_cmp(&other.payload.StaleNetworkFileHandle),
                    StorageFull => self
                        .payload
                        .StorageFull
                        .partial_cmp(&other.payload.StorageFull),
                    TimedOut => self.payload.TimedOut.partial_cmp(&other.payload.TimedOut),
                    TooManyHardlinks => self
                        .payload
                        .TooManyHardlinks
                        .partial_cmp(&other.payload.TooManyHardlinks),
                    TooManySymlinks => self
                        .payload
                        .TooManySymlinks
                        .partial_cmp(&other.payload.TooManySymlinks),
                    Unrecognized => self
                        .payload
                        .Unrecognized
                        .partial_cmp(&other.payload.Unrecognized),
                    Unsupported => self
                        .payload
                        .Unsupported
                        .partial_cmp(&other.payload.Unsupported),
                    WasADirectory => self
                        .payload
                        .WasADirectory
                        .partial_cmp(&other.payload.WasADirectory),
                    WriteZero => self.payload.WriteZero.partial_cmp(&other.payload.WriteZero),
                }
            },
        }
    }
}

impl core::hash::Hash for WriteErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_WriteErr::*;

        unsafe {
            match self.discriminant {
                AlreadyExists => self.payload.AlreadyExists.hash(state),
                ExecutableFileBusy => self.payload.ExecutableFileBusy.hash(state),
                FileTooLarge => self.payload.FileTooLarge.hash(state),
                FilesystemQuotaExceeded => self.payload.FilesystemQuotaExceeded.hash(state),
                Interrupted => self.payload.Interrupted.hash(state),
                InvalidFilename => self.payload.InvalidFilename.hash(state),
                NotFound => self.payload.NotFound.hash(state),
                OutOfMemory => self.payload.OutOfMemory.hash(state),
                PermissionDenied => self.payload.PermissionDenied.hash(state),
                ReadOnlyFilesystem => self.payload.ReadOnlyFilesystem.hash(state),
                ResourceBusy => self.payload.ResourceBusy.hash(state),
                StaleNetworkFileHandle => self.payload.StaleNetworkFileHandle.hash(state),
                StorageFull => self.payload.StorageFull.hash(state),
                TimedOut => self.payload.TimedOut.hash(state),
                TooManyHardlinks => self.payload.TooManyHardlinks.hash(state),
                TooManySymlinks => self.payload.TooManySymlinks.hash(state),
                Unrecognized => self.payload.Unrecognized.hash(state),
                Unsupported => self.payload.Unsupported.hash(state),
                WasADirectory => self.payload.WasADirectory.hash(state),
                WriteZero => self.payload.WriteZero.hash(state),
            }
        }
    }
}

impl WriteErr {
    pub fn is_AlreadyExists(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::AlreadyExists)
    }

    pub fn is_ExecutableFileBusy(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::ExecutableFileBusy)
    }

    pub fn is_FileTooLarge(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::FileTooLarge)
    }

    pub fn is_FilesystemQuotaExceeded(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_WriteErr::FilesystemQuotaExceeded
        )
    }

    pub fn is_Interrupted(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::Interrupted)
    }

    pub fn is_InvalidFilename(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::InvalidFilename)
    }

    pub fn is_NotFound(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::NotFound)
    }

    pub fn is_OutOfMemory(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::OutOfMemory)
    }

    pub fn is_PermissionDenied(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::PermissionDenied)
    }

    pub fn is_ReadOnlyFilesystem(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::ReadOnlyFilesystem)
    }

    pub fn is_ResourceBusy(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::ResourceBusy)
    }

    pub fn is_StaleNetworkFileHandle(&self) -> bool {
        matches!(
            self.discriminant,
            discriminant_WriteErr::StaleNetworkFileHandle
        )
    }

    pub fn is_StorageFull(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::StorageFull)
    }

    pub fn is_TimedOut(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::TimedOut)
    }

    pub fn is_TooManyHardlinks(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::TooManyHardlinks)
    }

    pub fn is_TooManySymlinks(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::TooManySymlinks)
    }

    pub fn unwrap_Unrecognized(mut self) -> ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_WriteErr::Unrecognized);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Unrecognized) }
    }

    pub fn borrow_Unrecognized(&self) -> &ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_WriteErr::Unrecognized);
        use core::borrow::Borrow;
        unsafe { self.payload.Unrecognized.borrow() }
    }

    pub fn borrow_mut_Unrecognized(&mut self) -> &mut ConnectErr_Unrecognized {
        debug_assert_eq!(self.discriminant, discriminant_WriteErr::Unrecognized);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Unrecognized.borrow_mut() }
    }

    pub fn is_Unrecognized(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::Unrecognized)
    }

    pub fn is_Unsupported(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::Unsupported)
    }

    pub fn is_WasADirectory(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::WasADirectory)
    }

    pub fn is_WriteZero(&self) -> bool {
        matches!(self.discriminant, discriminant_WriteErr::WriteZero)
    }
}

impl WriteErr {
    pub fn AlreadyExists() -> Self {
        Self {
            discriminant: discriminant_WriteErr::AlreadyExists,
            payload: union_WriteErr { AlreadyExists: () },
        }
    }

    pub fn ExecutableFileBusy() -> Self {
        Self {
            discriminant: discriminant_WriteErr::ExecutableFileBusy,
            payload: union_WriteErr {
                ExecutableFileBusy: (),
            },
        }
    }

    pub fn FileTooLarge() -> Self {
        Self {
            discriminant: discriminant_WriteErr::FileTooLarge,
            payload: union_WriteErr { FileTooLarge: () },
        }
    }

    pub fn FilesystemQuotaExceeded() -> Self {
        Self {
            discriminant: discriminant_WriteErr::FilesystemQuotaExceeded,
            payload: union_WriteErr {
                FilesystemQuotaExceeded: (),
            },
        }
    }

    pub fn Interrupted() -> Self {
        Self {
            discriminant: discriminant_WriteErr::Interrupted,
            payload: union_WriteErr { Interrupted: () },
        }
    }

    pub fn InvalidFilename() -> Self {
        Self {
            discriminant: discriminant_WriteErr::InvalidFilename,
            payload: union_WriteErr {
                InvalidFilename: (),
            },
        }
    }

    pub fn NotFound() -> Self {
        Self {
            discriminant: discriminant_WriteErr::NotFound,
            payload: union_WriteErr { NotFound: () },
        }
    }

    pub fn OutOfMemory() -> Self {
        Self {
            discriminant: discriminant_WriteErr::OutOfMemory,
            payload: union_WriteErr { OutOfMemory: () },
        }
    }

    pub fn PermissionDenied() -> Self {
        Self {
            discriminant: discriminant_WriteErr::PermissionDenied,
            payload: union_WriteErr {
                PermissionDenied: (),
            },
        }
    }

    pub fn ReadOnlyFilesystem() -> Self {
        Self {
            discriminant: discriminant_WriteErr::ReadOnlyFilesystem,
            payload: union_WriteErr {
                ReadOnlyFilesystem: (),
            },
        }
    }

    pub fn ResourceBusy() -> Self {
        Self {
            discriminant: discriminant_WriteErr::ResourceBusy,
            payload: union_WriteErr { ResourceBusy: () },
        }
    }

    pub fn StaleNetworkFileHandle() -> Self {
        Self {
            discriminant: discriminant_WriteErr::StaleNetworkFileHandle,
            payload: union_WriteErr {
                StaleNetworkFileHandle: (),
            },
        }
    }

    pub fn StorageFull() -> Self {
        Self {
            discriminant: discriminant_WriteErr::StorageFull,
            payload: union_WriteErr { StorageFull: () },
        }
    }

    pub fn TimedOut() -> Self {
        Self {
            discriminant: discriminant_WriteErr::TimedOut,
            payload: union_WriteErr { TimedOut: () },
        }
    }

    pub fn TooManyHardlinks() -> Self {
        Self {
            discriminant: discriminant_WriteErr::TooManyHardlinks,
            payload: union_WriteErr {
                TooManyHardlinks: (),
            },
        }
    }

    pub fn TooManySymlinks() -> Self {
        Self {
            discriminant: discriminant_WriteErr::TooManySymlinks,
            payload: union_WriteErr {
                TooManySymlinks: (),
            },
        }
    }

    pub fn Unrecognized(payload: ConnectErr_Unrecognized) -> Self {
        Self {
            discriminant: discriminant_WriteErr::Unrecognized,
            payload: union_WriteErr {
                Unrecognized: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Unsupported() -> Self {
        Self {
            discriminant: discriminant_WriteErr::Unsupported,
            payload: union_WriteErr { Unsupported: () },
        }
    }

    pub fn WasADirectory() -> Self {
        Self {
            discriminant: discriminant_WriteErr::WasADirectory,
            payload: union_WriteErr { WasADirectory: () },
        }
    }

    pub fn WriteZero() -> Self {
        Self {
            discriminant: discriminant_WriteErr::WriteZero,
            payload: union_WriteErr { WriteZero: () },
        }
    }
}

impl Drop for WriteErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_WriteErr::AlreadyExists => {}
            discriminant_WriteErr::ExecutableFileBusy => {}
            discriminant_WriteErr::FileTooLarge => {}
            discriminant_WriteErr::FilesystemQuotaExceeded => {}
            discriminant_WriteErr::Interrupted => {}
            discriminant_WriteErr::InvalidFilename => {}
            discriminant_WriteErr::NotFound => {}
            discriminant_WriteErr::OutOfMemory => {}
            discriminant_WriteErr::PermissionDenied => {}
            discriminant_WriteErr::ReadOnlyFilesystem => {}
            discriminant_WriteErr::ResourceBusy => {}
            discriminant_WriteErr::StaleNetworkFileHandle => {}
            discriminant_WriteErr::StorageFull => {}
            discriminant_WriteErr::TimedOut => {}
            discriminant_WriteErr::TooManyHardlinks => {}
            discriminant_WriteErr::TooManySymlinks => {}
            discriminant_WriteErr::Unrecognized => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Unrecognized)
            },
            discriminant_WriteErr::Unsupported => {}
            discriminant_WriteErr::WasADirectory => {}
            discriminant_WriteErr::WriteZero => {}
        }
    }
}

impl roc_std::RocRefcounted for WriteErr {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum SqliteState {
    Done = 0,
    Row = 1,
}

impl core::fmt::Debug for SqliteState {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Done => f.write_str("SqliteState::Done"),
            Self::Row => f.write_str("SqliteState::Row"),
        }
    }
}

roc_refcounted_noop_impl!(SqliteState);

#[derive(Clone, Debug, PartialEq, PartialOrd)]
#[repr(C)]
pub struct GlueTypes {
    pub d: ConnectResult,
    pub k: SqliteBindings,
    pub l: SqliteError,
    pub n: SqliteValue,
    pub a: InternalCommand,
    pub b: InternalOutput,
    pub c: InternalCommandErr,
    pub e: ReadResult,
    pub f: ReadExactlyResult,
    pub g: WriteResult,
    pub h: ConnectErr,
    pub i: StreamErr,
    pub j: InternalDirReadErr,
    pub o: ReadErr,
    pub p: WriteErr,
    pub m: SqliteState,
}

impl roc_std::RocRefcounted for GlueTypes {
    fn inc(&mut self) {
        self.d.inc();
        self.k.inc();
        self.l.inc();
        self.n.inc();
        self.a.inc();
        self.b.inc();
        self.c.inc();
        self.e.inc();
        self.f.inc();
        self.g.inc();
        self.h.inc();
        self.i.inc();
        self.j.inc();
        self.o.inc();
        self.p.inc();
    }
    fn dec(&mut self) {
        self.d.dec();
        self.k.dec();
        self.l.dec();
        self.n.dec();
        self.a.dec();
        self.b.dec();
        self.c.dec();
        self.e.dec();
        self.f.dec();
        self.g.dec();
        self.h.dec();
        self.i.dec();
        self.j.dec();
        self.o.dec();
        self.p.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}
