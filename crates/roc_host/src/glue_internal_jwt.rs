// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command
//
// ... and then manually edited to fix issues and rename things.

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::non_canonical_partial_ord_impl)]

use roc_std::roc_refcounted_noop_impl;
use roc_std::RocRefcounted;

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Claim {
    pub key: roc_std::RocStr,
    pub value: roc_std::RocStr,
}

impl roc_std::RocRefcounted for Claim {
    fn inc(&mut self) {
        self.key.inc();
        self.value.inc();
    }
    fn dec(&mut self) {
        self.key.dec();
        self.value.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Header {
    pub alg: roc_std::RocStr,
    pub cty: roc_std::RocStr,
    pub jku: roc_std::RocStr,
    pub jwk: roc_std::RocStr,
    pub kid: roc_std::RocStr,
    pub typ: roc_std::RocStr,
    pub x5c: roc_std::RocStr,
    pub x5t: roc_std::RocStr,
    pub x5tS256: roc_std::RocStr,
    pub x5u: roc_std::RocStr,
}

impl roc_std::RocRefcounted for Header {
    fn inc(&mut self) {
        self.alg.inc();
        self.cty.inc();
        self.jku.inc();
        self.jwk.inc();
        self.kid.inc();
        self.typ.inc();
        self.x5c.inc();
        self.x5t.inc();
        self.x5tS256.inc();
        self.x5u.inc();
    }
    fn dec(&mut self) {
        self.alg.dec();
        self.cty.dec();
        self.jku.dec();
        self.jwk.dec();
        self.kid.dec();
        self.typ.dec();
        self.x5c.dec();
        self.x5t.dec();
        self.x5tS256.dec();
        self.x5u.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Token {
    pub claims: roc_std::RocList<Claim>,
    pub header: Header,
}

impl roc_std::RocRefcounted for Token {
    fn inc(&mut self) {
        self.claims.inc();
        self.header.inc();
    }
    fn dec(&mut self) {
        self.claims.dec();
        self.header.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum Algorithm {
    ES256 = 0,
    ES384 = 1,
    EdDSA = 2,
    HS256 = 3,
    HS384 = 4,
    HS512 = 5,
    PS256 = 6,
    PS384 = 7,
    PS512 = 8,
    RS256 = 9,
    RS384 = 10,
    RS512 = 11,
}

impl core::fmt::Debug for Algorithm {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ES256 => f.write_str("Algorithm::ES256"),
            Self::ES384 => f.write_str("Algorithm::ES384"),
            Self::EdDSA => f.write_str("Algorithm::EdDSA"),
            Self::HS256 => f.write_str("Algorithm::HS256"),
            Self::HS384 => f.write_str("Algorithm::HS384"),
            Self::HS512 => f.write_str("Algorithm::HS512"),
            Self::PS256 => f.write_str("Algorithm::PS256"),
            Self::PS384 => f.write_str("Algorithm::PS384"),
            Self::PS512 => f.write_str("Algorithm::PS512"),
            Self::RS256 => f.write_str("Algorithm::RS256"),
            Self::RS384 => f.write_str("Algorithm::RS384"),
            Self::RS512 => f.write_str("Algorithm::RS512"),
        }
    }
}

roc_refcounted_noop_impl!(Algorithm);

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Validation {
    pub algorithms: roc_std::RocList<Algorithm>,
    pub audience: roc_std::RocStr,
    pub issuer: roc_std::RocStr,
    pub leeway: u64,
    pub rejectExiringLessThan: u64,
    pub requiredClaims: roc_std::RocList<roc_std::RocStr>,
    pub subject: roc_std::RocStr,
    pub validateAud: bool,
    pub validateExp: bool,
    pub validateNbf: bool,
}

impl roc_std::RocRefcounted for Validation {
    fn inc(&mut self) {
        self.algorithms.inc();
        self.audience.inc();
        self.issuer.inc();
        self.requiredClaims.inc();
        self.subject.inc();
    }
    fn dec(&mut self) {
        self.algorithms.dec();
        self.audience.dec();
        self.issuer.dec();
        self.requiredClaims.dec();
        self.subject.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_Err {
    InvalidAlgorithm = 0,
    InvalidClaim = 1,
    InvalidKey = 2,
    InvalidSignature = 3,
    InvalidToken = 4,
    MissingClaim = 5,
    Other = 6,
}

impl core::fmt::Debug for discriminant_Err {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidAlgorithm => f.write_str("discriminant_Err::InvalidAlgorithm"),
            Self::InvalidClaim => f.write_str("discriminant_Err::InvalidClaim"),
            Self::InvalidKey => f.write_str("discriminant_Err::InvalidKey"),
            Self::InvalidSignature => f.write_str("discriminant_Err::InvalidSignature"),
            Self::InvalidToken => f.write_str("discriminant_Err::InvalidToken"),
            Self::MissingClaim => f.write_str("discriminant_Err::MissingClaim"),
            Self::Other => f.write_str("discriminant_Err::Other"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_Err);

#[repr(C, align(8))]
pub union union_Err {
    InvalidAlgorithm: core::mem::ManuallyDrop<roc_std::RocStr>,
    InvalidClaim: core::mem::ManuallyDrop<roc_std::RocStr>,
    InvalidKey: core::mem::ManuallyDrop<roc_std::RocStr>,
    InvalidSignature: core::mem::ManuallyDrop<roc_std::RocStr>,
    InvalidToken: core::mem::ManuallyDrop<roc_std::RocStr>,
    MissingClaim: core::mem::ManuallyDrop<roc_std::RocStr>,
    Other: core::mem::ManuallyDrop<roc_std::RocStr>,
}

const _SIZE_CHECK_union_Err: () = assert!(core::mem::size_of::<union_Err>() == 24);
const _ALIGN_CHECK_union_Err: () = assert!(core::mem::align_of::<union_Err>() == 8);

const _SIZE_CHECK_Err: () = assert!(core::mem::size_of::<JwtErr>() == 32);
const _ALIGN_CHECK_Err: () = assert!(core::mem::align_of::<JwtErr>() == 8);

impl JwtErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Err {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Err>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Err) {
        let discriminant_ptr: *mut discriminant_Err = (self as *mut JwtErr).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct JwtErr {
    payload: union_Err,
    discriminant: discriminant_Err,
}

impl Clone for JwtErr {
    fn clone(&self) -> Self {
        use discriminant_Err::*;

        let payload = unsafe {
            match self.discriminant {
                InvalidAlgorithm => union_Err {
                    InvalidAlgorithm: self.payload.InvalidAlgorithm.clone(),
                },
                InvalidClaim => union_Err {
                    InvalidClaim: self.payload.InvalidClaim.clone(),
                },
                InvalidKey => union_Err {
                    InvalidKey: self.payload.InvalidKey.clone(),
                },
                InvalidSignature => union_Err {
                    InvalidSignature: self.payload.InvalidSignature.clone(),
                },
                InvalidToken => union_Err {
                    InvalidToken: self.payload.InvalidToken.clone(),
                },
                MissingClaim => union_Err {
                    MissingClaim: self.payload.MissingClaim.clone(),
                },
                Other => union_Err {
                    Other: self.payload.Other.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for JwtErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_Err::*;

        unsafe {
            match self.discriminant {
                InvalidAlgorithm => {
                    let field: &roc_std::RocStr = &self.payload.InvalidAlgorithm;
                    f.debug_tuple("Err::InvalidAlgorithm").field(field).finish()
                }
                InvalidClaim => {
                    let field: &roc_std::RocStr = &self.payload.InvalidClaim;
                    f.debug_tuple("Err::InvalidClaim").field(field).finish()
                }
                InvalidKey => {
                    let field: &roc_std::RocStr = &self.payload.InvalidKey;
                    f.debug_tuple("Err::InvalidKey").field(field).finish()
                }
                InvalidSignature => {
                    let field: &roc_std::RocStr = &self.payload.InvalidSignature;
                    f.debug_tuple("Err::InvalidSignature").field(field).finish()
                }
                InvalidToken => {
                    let field: &roc_std::RocStr = &self.payload.InvalidToken;
                    f.debug_tuple("Err::InvalidToken").field(field).finish()
                }
                MissingClaim => {
                    let field: &roc_std::RocStr = &self.payload.MissingClaim;
                    f.debug_tuple("Err::MissingClaim").field(field).finish()
                }
                Other => {
                    let field: &roc_std::RocStr = &self.payload.Other;
                    f.debug_tuple("Err::Other").field(field).finish()
                }
            }
        }
    }
}

impl Eq for JwtErr {}

impl PartialEq for JwtErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_Err::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                InvalidAlgorithm => self.payload.InvalidAlgorithm == other.payload.InvalidAlgorithm,
                InvalidClaim => self.payload.InvalidClaim == other.payload.InvalidClaim,
                InvalidKey => self.payload.InvalidKey == other.payload.InvalidKey,
                InvalidSignature => self.payload.InvalidSignature == other.payload.InvalidSignature,
                InvalidToken => self.payload.InvalidToken == other.payload.InvalidToken,
                MissingClaim => self.payload.MissingClaim == other.payload.MissingClaim,
                Other => self.payload.Other == other.payload.Other,
            }
        }
    }
}

impl Ord for JwtErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for JwtErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_Err::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    InvalidAlgorithm => self
                        .payload
                        .InvalidAlgorithm
                        .partial_cmp(&other.payload.InvalidAlgorithm),
                    InvalidClaim => self
                        .payload
                        .InvalidClaim
                        .partial_cmp(&other.payload.InvalidClaim),
                    InvalidKey => self
                        .payload
                        .InvalidKey
                        .partial_cmp(&other.payload.InvalidKey),
                    InvalidSignature => self
                        .payload
                        .InvalidSignature
                        .partial_cmp(&other.payload.InvalidSignature),
                    InvalidToken => self
                        .payload
                        .InvalidToken
                        .partial_cmp(&other.payload.InvalidToken),
                    MissingClaim => self
                        .payload
                        .MissingClaim
                        .partial_cmp(&other.payload.MissingClaim),
                    Other => self.payload.Other.partial_cmp(&other.payload.Other),
                }
            },
        }
    }
}

impl core::hash::Hash for JwtErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_Err::*;

        unsafe {
            match self.discriminant {
                InvalidAlgorithm => self.payload.InvalidAlgorithm.hash(state),
                InvalidClaim => self.payload.InvalidClaim.hash(state),
                InvalidKey => self.payload.InvalidKey.hash(state),
                InvalidSignature => self.payload.InvalidSignature.hash(state),
                InvalidToken => self.payload.InvalidToken.hash(state),
                MissingClaim => self.payload.MissingClaim.hash(state),
                Other => self.payload.Other.hash(state),
            }
        }
    }
}

impl JwtErr {
    pub fn unwrap_InvalidAlgorithm(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidAlgorithm);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.InvalidAlgorithm) }
    }

    pub fn borrow_InvalidAlgorithm(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidAlgorithm);
        use core::borrow::Borrow;
        unsafe { self.payload.InvalidAlgorithm.borrow() }
    }

    pub fn borrow_mut_InvalidAlgorithm(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidAlgorithm);
        use core::borrow::BorrowMut;
        unsafe { self.payload.InvalidAlgorithm.borrow_mut() }
    }

    pub fn is_InvalidAlgorithm(&self) -> bool {
        matches!(self.discriminant, discriminant_Err::InvalidAlgorithm)
    }

    pub fn unwrap_InvalidClaim(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidClaim);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.InvalidClaim) }
    }

    pub fn borrow_InvalidClaim(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidClaim);
        use core::borrow::Borrow;
        unsafe { self.payload.InvalidClaim.borrow() }
    }

    pub fn borrow_mut_InvalidClaim(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidClaim);
        use core::borrow::BorrowMut;
        unsafe { self.payload.InvalidClaim.borrow_mut() }
    }

    pub fn is_InvalidClaim(&self) -> bool {
        matches!(self.discriminant, discriminant_Err::InvalidClaim)
    }

    pub fn unwrap_InvalidKey(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidKey);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.InvalidKey) }
    }

    pub fn borrow_InvalidKey(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidKey);
        use core::borrow::Borrow;
        unsafe { self.payload.InvalidKey.borrow() }
    }

    pub fn borrow_mut_InvalidKey(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidKey);
        use core::borrow::BorrowMut;
        unsafe { self.payload.InvalidKey.borrow_mut() }
    }

    pub fn is_InvalidKey(&self) -> bool {
        matches!(self.discriminant, discriminant_Err::InvalidKey)
    }

    pub fn unwrap_InvalidSignature(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidSignature);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.InvalidSignature) }
    }

    pub fn borrow_InvalidSignature(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidSignature);
        use core::borrow::Borrow;
        unsafe { self.payload.InvalidSignature.borrow() }
    }

    pub fn borrow_mut_InvalidSignature(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidSignature);
        use core::borrow::BorrowMut;
        unsafe { self.payload.InvalidSignature.borrow_mut() }
    }

    pub fn is_InvalidSignature(&self) -> bool {
        matches!(self.discriminant, discriminant_Err::InvalidSignature)
    }

    pub fn unwrap_InvalidToken(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidToken);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.InvalidToken) }
    }

    pub fn borrow_InvalidToken(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidToken);
        use core::borrow::Borrow;
        unsafe { self.payload.InvalidToken.borrow() }
    }

    pub fn borrow_mut_InvalidToken(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::InvalidToken);
        use core::borrow::BorrowMut;
        unsafe { self.payload.InvalidToken.borrow_mut() }
    }

    pub fn is_InvalidToken(&self) -> bool {
        matches!(self.discriminant, discriminant_Err::InvalidToken)
    }

    pub fn unwrap_MissingClaim(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::MissingClaim);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.MissingClaim) }
    }

    pub fn borrow_MissingClaim(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::MissingClaim);
        use core::borrow::Borrow;
        unsafe { self.payload.MissingClaim.borrow() }
    }

    pub fn borrow_mut_MissingClaim(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::MissingClaim);
        use core::borrow::BorrowMut;
        unsafe { self.payload.MissingClaim.borrow_mut() }
    }

    pub fn is_MissingClaim(&self) -> bool {
        matches!(self.discriminant, discriminant_Err::MissingClaim)
    }

    pub fn unwrap_Other(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::Other);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Other) }
    }

    pub fn borrow_Other(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::Other);
        use core::borrow::Borrow;
        unsafe { self.payload.Other.borrow() }
    }

    pub fn borrow_mut_Other(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_Err::Other);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Other.borrow_mut() }
    }

    pub fn is_Other(&self) -> bool {
        matches!(self.discriminant, discriminant_Err::Other)
    }
}

impl JwtErr {
    pub fn InvalidAlgorithm(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Err::InvalidAlgorithm,
            payload: union_Err {
                InvalidAlgorithm: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn InvalidClaim(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Err::InvalidClaim,
            payload: union_Err {
                InvalidClaim: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn InvalidKey(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Err::InvalidKey,
            payload: union_Err {
                InvalidKey: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn InvalidSignature(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Err::InvalidSignature,
            payload: union_Err {
                InvalidSignature: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn InvalidToken(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Err::InvalidToken,
            payload: union_Err {
                InvalidToken: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn MissingClaim(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Err::MissingClaim,
            payload: union_Err {
                MissingClaim: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn Other(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_Err::Other,
            payload: union_Err {
                Other: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for JwtErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Err::InvalidAlgorithm => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.InvalidAlgorithm)
            },
            discriminant_Err::InvalidClaim => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.InvalidClaim)
            },
            discriminant_Err::InvalidKey => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.InvalidKey)
            },
            discriminant_Err::InvalidSignature => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.InvalidSignature)
            },
            discriminant_Err::InvalidToken => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.InvalidToken)
            },
            discriminant_Err::MissingClaim => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.MissingClaim)
            },
            discriminant_Err::Other => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Other)
            },
        }
    }
}

// NOTE this was manually implemented
impl roc_std::RocRefcounted for JwtErr {
    fn inc(&mut self) {
        dbg!("doing nasty things INC");
        match self.discriminant() {
            discriminant_Err::InvalidAlgorithm => unsafe { (*self.payload.InvalidAlgorithm).inc() },
            discriminant_Err::InvalidClaim => unsafe { (*self.payload.InvalidClaim).inc() },
            discriminant_Err::InvalidKey => unsafe { (*self.payload.InvalidKey).inc() },
            discriminant_Err::InvalidSignature => unsafe { (*self.payload.InvalidSignature).inc() },
            discriminant_Err::InvalidToken => unsafe { (*self.payload.InvalidToken).inc() },
            discriminant_Err::MissingClaim => unsafe { (*self.payload.MissingClaim).inc() },
            discriminant_Err::Other => unsafe { (*self.payload.Other).inc() },
        }
    }
    fn dec(&mut self) {
        dbg!("doing nasty things DEC");
        match self.discriminant() {
            discriminant_Err::InvalidAlgorithm => unsafe { (*self.payload.InvalidAlgorithm).dec() },
            discriminant_Err::InvalidClaim => unsafe { (*self.payload.InvalidClaim).dec() },
            discriminant_Err::InvalidKey => unsafe { (*self.payload.InvalidKey).dec() },
            discriminant_Err::InvalidSignature => unsafe { (*self.payload.InvalidSignature).dec() },
            discriminant_Err::InvalidToken => unsafe { (*self.payload.InvalidToken).dec() },
            discriminant_Err::MissingClaim => unsafe { (*self.payload.MissingClaim).dec() },
            discriminant_Err::Other => unsafe { (*self.payload.Other).dec() },
        }
    }
    fn is_refcounted() -> bool {
        true
    }
}
