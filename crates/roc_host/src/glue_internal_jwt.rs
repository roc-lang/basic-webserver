// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command
//
// ... and then manually edited to fix issues and rename things.

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::non_canonical_partial_ord_impl)]

use roc_std::roc_refcounted_noop_impl;
use roc_std::RocRefcounted;

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Claim {
    pub key: roc_std::RocStr,
    pub value: roc_std::RocStr,
}

impl roc_std::RocRefcounted for Claim {
    fn inc(&mut self) {
        self.key.inc();
        self.value.inc();
    }
    fn dec(&mut self) {
        self.key.dec();
        self.value.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Header {
    pub alg: roc_std::RocStr,
    pub cty: roc_std::RocStr,
    pub jku: roc_std::RocStr,
    pub jwk: roc_std::RocStr,
    pub kid: roc_std::RocStr,
    pub typ: roc_std::RocStr,
    pub x5c: roc_std::RocStr,
    pub x5t: roc_std::RocStr,
    pub x5tS256: roc_std::RocStr,
    pub x5u: roc_std::RocStr,
}

impl roc_std::RocRefcounted for Header {
    fn inc(&mut self) {
        self.alg.inc();
        self.cty.inc();
        self.jku.inc();
        self.jwk.inc();
        self.kid.inc();
        self.typ.inc();
        self.x5c.inc();
        self.x5t.inc();
        self.x5tS256.inc();
        self.x5u.inc();
    }
    fn dec(&mut self) {
        self.alg.dec();
        self.cty.dec();
        self.jku.dec();
        self.jwk.dec();
        self.kid.dec();
        self.typ.dec();
        self.x5c.dec();
        self.x5t.dec();
        self.x5tS256.dec();
        self.x5u.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Token {
    pub claims: roc_std::RocList<Claim>,
    pub header: Header,
}

impl roc_std::RocRefcounted for Token {
    fn inc(&mut self) {
        self.claims.inc();
        self.header.inc();
    }
    fn dec(&mut self) {
        self.claims.dec();
        self.header.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum Algorithm {
    ES256 = 0,
    ES384 = 1,
    EdDSA = 2,
    HS256 = 3,
    HS384 = 4,
    HS512 = 5,
    PS256 = 6,
    PS384 = 7,
    PS512 = 8,
    RS256 = 9,
    RS384 = 10,
    RS512 = 11,
}

impl core::fmt::Debug for Algorithm {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ES256 => f.write_str("Algorithm::ES256"),
            Self::ES384 => f.write_str("Algorithm::ES384"),
            Self::EdDSA => f.write_str("Algorithm::EdDSA"),
            Self::HS256 => f.write_str("Algorithm::HS256"),
            Self::HS384 => f.write_str("Algorithm::HS384"),
            Self::HS512 => f.write_str("Algorithm::HS512"),
            Self::PS256 => f.write_str("Algorithm::PS256"),
            Self::PS384 => f.write_str("Algorithm::PS384"),
            Self::PS512 => f.write_str("Algorithm::PS512"),
            Self::RS256 => f.write_str("Algorithm::RS256"),
            Self::RS384 => f.write_str("Algorithm::RS384"),
            Self::RS512 => f.write_str("Algorithm::RS512"),
        }
    }
}

roc_refcounted_noop_impl!(Algorithm);

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(C)]
pub struct Validation {
    pub algorithms: roc_std::RocList<Algorithm>,
    pub audience: roc_std::RocStr,
    pub issuer: roc_std::RocStr,
    pub leeway: u64,
    pub rejectExiringLessThan: u64,
    pub requiredClaims: roc_std::RocList<roc_std::RocStr>,
    pub subject: roc_std::RocStr,
    pub validateAud: bool,
    pub validateExp: bool,
    pub validateNbf: bool,
}

impl roc_std::RocRefcounted for Validation {
    fn inc(&mut self) {
        self.algorithms.inc();
        self.audience.inc();
        self.issuer.inc();
        self.requiredClaims.inc();
        self.subject.inc();
    }
    fn dec(&mut self) {
        self.algorithms.dec();
        self.audience.dec();
        self.issuer.dec();
        self.requiredClaims.dec();
        self.subject.dec();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]
#[repr(u8)]
pub enum discriminant_JwtErr {
    Base64 = 0,
    ExpiredSignature = 1,
    ImmatureSignature = 2,
    InvalidAlgorithm = 3,
    InvalidAlgorithmName = 4,
    InvalidAudience = 5,
    InvalidEcdsaKey = 6,
    InvalidIssuer = 7,
    InvalidKeyFormat = 8,
    InvalidRsaKey = 9,
    InvalidSignature = 10,
    InvalidSubject = 11,
    InvalidToken = 12,
    Json = 13,
    MissingAlgorithm = 14,
    MissingRequiredClaim = 15,
    RsaFailedSigning = 16,
    UnspecifiedCrypto = 17,
    Utf8 = 18,
}

impl core::fmt::Debug for discriminant_JwtErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Base64 => f.write_str("discriminant_JwtErr::Base64"),
            Self::ExpiredSignature => f.write_str("discriminant_JwtErr::ExpiredSignature"),
            Self::ImmatureSignature => f.write_str("discriminant_JwtErr::ImmatureSignature"),
            Self::InvalidAlgorithm => f.write_str("discriminant_JwtErr::InvalidAlgorithm"),
            Self::InvalidAlgorithmName => f.write_str("discriminant_JwtErr::InvalidAlgorithmName"),
            Self::InvalidAudience => f.write_str("discriminant_JwtErr::InvalidAudience"),
            Self::InvalidEcdsaKey => f.write_str("discriminant_JwtErr::InvalidEcdsaKey"),
            Self::InvalidIssuer => f.write_str("discriminant_JwtErr::InvalidIssuer"),
            Self::InvalidKeyFormat => f.write_str("discriminant_JwtErr::InvalidKeyFormat"),
            Self::InvalidRsaKey => f.write_str("discriminant_JwtErr::InvalidRsaKey"),
            Self::InvalidSignature => f.write_str("discriminant_JwtErr::InvalidSignature"),
            Self::InvalidSubject => f.write_str("discriminant_JwtErr::InvalidSubject"),
            Self::InvalidToken => f.write_str("discriminant_JwtErr::InvalidToken"),
            Self::Json => f.write_str("discriminant_JwtErr::Json"),
            Self::MissingAlgorithm => f.write_str("discriminant_JwtErr::MissingAlgorithm"),
            Self::MissingRequiredClaim => f.write_str("discriminant_JwtErr::MissingRequiredClaim"),
            Self::RsaFailedSigning => f.write_str("discriminant_JwtErr::RsaFailedSigning"),
            Self::UnspecifiedCrypto => f.write_str("discriminant_JwtErr::UnspecifiedCrypto"),
            Self::Utf8 => f.write_str("discriminant_JwtErr::Utf8"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_JwtErr);

#[repr(C, align(8))]
pub union union_JwtErr {
    Base64: core::mem::ManuallyDrop<roc_std::RocStr>,
    ExpiredSignature: (),
    ImmatureSignature: (),
    InvalidAlgorithm: (),
    InvalidAlgorithmName: (),
    InvalidAudience: (),
    InvalidEcdsaKey: (),
    InvalidIssuer: (),
    InvalidKeyFormat: (),
    InvalidRsaKey: core::mem::ManuallyDrop<roc_std::RocStr>,
    InvalidSignature: (),
    InvalidSubject: (),
    InvalidToken: (),
    Json: core::mem::ManuallyDrop<roc_std::RocStr>,
    MissingAlgorithm: (),
    MissingRequiredClaim: core::mem::ManuallyDrop<roc_std::RocStr>,
    RsaFailedSigning: (),
    UnspecifiedCrypto: (),
    Utf8: core::mem::ManuallyDrop<roc_std::RocStr>,
}

const _SIZE_CHECK_union_JwtErr: () = assert!(core::mem::size_of::<union_JwtErr>() == 24);
const _ALIGN_CHECK_union_JwtErr: () = assert!(core::mem::align_of::<union_JwtErr>() == 8);

const _SIZE_CHECK_JwtErr: () = assert!(core::mem::size_of::<JwtErr>() == 32);
const _ALIGN_CHECK_JwtErr: () = assert!(core::mem::align_of::<JwtErr>() == 8);

impl JwtErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_JwtErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_JwtErr>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_JwtErr) {
        let discriminant_ptr: *mut discriminant_JwtErr = (self as *mut JwtErr).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct JwtErr {
    payload: union_JwtErr,
    discriminant: discriminant_JwtErr,
}

impl Clone for JwtErr {
    fn clone(&self) -> Self {
        use discriminant_JwtErr::*;

        let payload = unsafe {
            match self.discriminant {
                Base64 => union_JwtErr {
                    Base64: self.payload.Base64.clone(),
                },
                ExpiredSignature => union_JwtErr {
                    ExpiredSignature: self.payload.ExpiredSignature.clone(),
                },
                ImmatureSignature => union_JwtErr {
                    ImmatureSignature: self.payload.ImmatureSignature.clone(),
                },
                InvalidAlgorithm => union_JwtErr {
                    InvalidAlgorithm: self.payload.InvalidAlgorithm.clone(),
                },
                InvalidAlgorithmName => union_JwtErr {
                    InvalidAlgorithmName: self.payload.InvalidAlgorithmName.clone(),
                },
                InvalidAudience => union_JwtErr {
                    InvalidAudience: self.payload.InvalidAudience.clone(),
                },
                InvalidEcdsaKey => union_JwtErr {
                    InvalidEcdsaKey: self.payload.InvalidEcdsaKey.clone(),
                },
                InvalidIssuer => union_JwtErr {
                    InvalidIssuer: self.payload.InvalidIssuer.clone(),
                },
                InvalidKeyFormat => union_JwtErr {
                    InvalidKeyFormat: self.payload.InvalidKeyFormat.clone(),
                },
                InvalidRsaKey => union_JwtErr {
                    InvalidRsaKey: self.payload.InvalidRsaKey.clone(),
                },
                InvalidSignature => union_JwtErr {
                    InvalidSignature: self.payload.InvalidSignature.clone(),
                },
                InvalidSubject => union_JwtErr {
                    InvalidSubject: self.payload.InvalidSubject.clone(),
                },
                InvalidToken => union_JwtErr {
                    InvalidToken: self.payload.InvalidToken.clone(),
                },
                Json => union_JwtErr {
                    Json: self.payload.Json.clone(),
                },
                MissingAlgorithm => union_JwtErr {
                    MissingAlgorithm: self.payload.MissingAlgorithm.clone(),
                },
                MissingRequiredClaim => union_JwtErr {
                    MissingRequiredClaim: self.payload.MissingRequiredClaim.clone(),
                },
                RsaFailedSigning => union_JwtErr {
                    RsaFailedSigning: self.payload.RsaFailedSigning.clone(),
                },
                UnspecifiedCrypto => union_JwtErr {
                    UnspecifiedCrypto: self.payload.UnspecifiedCrypto.clone(),
                },
                Utf8 => union_JwtErr {
                    Utf8: self.payload.Utf8.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for JwtErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_JwtErr::*;

        unsafe {
            match self.discriminant {
                Base64 => {
                    let field: &roc_std::RocStr = &self.payload.Base64;
                    f.debug_tuple("JwtErr::Base64").field(field).finish()
                }
                ExpiredSignature => {
                    let field: &() = &self.payload.ExpiredSignature;
                    f.debug_tuple("JwtErr::ExpiredSignature")
                        .field(field)
                        .finish()
                }
                ImmatureSignature => {
                    let field: &() = &self.payload.ImmatureSignature;
                    f.debug_tuple("JwtErr::ImmatureSignature")
                        .field(field)
                        .finish()
                }
                InvalidAlgorithm => {
                    let field: &() = &self.payload.InvalidAlgorithm;
                    f.debug_tuple("JwtErr::InvalidAlgorithm")
                        .field(field)
                        .finish()
                }
                InvalidAlgorithmName => {
                    let field: &() = &self.payload.InvalidAlgorithmName;
                    f.debug_tuple("JwtErr::InvalidAlgorithmName")
                        .field(field)
                        .finish()
                }
                InvalidAudience => {
                    let field: &() = &self.payload.InvalidAudience;
                    f.debug_tuple("JwtErr::InvalidAudience")
                        .field(field)
                        .finish()
                }
                InvalidEcdsaKey => {
                    let field: &() = &self.payload.InvalidEcdsaKey;
                    f.debug_tuple("JwtErr::InvalidEcdsaKey")
                        .field(field)
                        .finish()
                }
                InvalidIssuer => {
                    let field: &() = &self.payload.InvalidIssuer;
                    f.debug_tuple("JwtErr::InvalidIssuer").field(field).finish()
                }
                InvalidKeyFormat => {
                    let field: &() = &self.payload.InvalidKeyFormat;
                    f.debug_tuple("JwtErr::InvalidKeyFormat")
                        .field(field)
                        .finish()
                }
                InvalidRsaKey => {
                    let field: &roc_std::RocStr = &self.payload.InvalidRsaKey;
                    f.debug_tuple("JwtErr::InvalidRsaKey").field(field).finish()
                }
                InvalidSignature => {
                    let field: &() = &self.payload.InvalidSignature;
                    f.debug_tuple("JwtErr::InvalidSignature")
                        .field(field)
                        .finish()
                }
                InvalidSubject => {
                    let field: &() = &self.payload.InvalidSubject;
                    f.debug_tuple("JwtErr::InvalidSubject")
                        .field(field)
                        .finish()
                }
                InvalidToken => {
                    let field: &() = &self.payload.InvalidToken;
                    f.debug_tuple("JwtErr::InvalidToken").field(field).finish()
                }
                Json => {
                    let field: &roc_std::RocStr = &self.payload.Json;
                    f.debug_tuple("JwtErr::Json").field(field).finish()
                }
                MissingAlgorithm => {
                    let field: &() = &self.payload.MissingAlgorithm;
                    f.debug_tuple("JwtErr::MissingAlgorithm")
                        .field(field)
                        .finish()
                }
                MissingRequiredClaim => {
                    let field: &roc_std::RocStr = &self.payload.MissingRequiredClaim;
                    f.debug_tuple("JwtErr::MissingRequiredClaim")
                        .field(field)
                        .finish()
                }
                RsaFailedSigning => {
                    let field: &() = &self.payload.RsaFailedSigning;
                    f.debug_tuple("JwtErr::RsaFailedSigning")
                        .field(field)
                        .finish()
                }
                UnspecifiedCrypto => {
                    let field: &() = &self.payload.UnspecifiedCrypto;
                    f.debug_tuple("JwtErr::UnspecifiedCrypto")
                        .field(field)
                        .finish()
                }
                Utf8 => {
                    let field: &roc_std::RocStr = &self.payload.Utf8;
                    f.debug_tuple("JwtErr::Utf8").field(field).finish()
                }
            }
        }
    }
}

impl Eq for JwtErr {}

impl PartialEq for JwtErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_JwtErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                Base64 => self.payload.Base64 == other.payload.Base64,
                ExpiredSignature => self.payload.ExpiredSignature == other.payload.ExpiredSignature,
                ImmatureSignature => {
                    self.payload.ImmatureSignature == other.payload.ImmatureSignature
                }
                InvalidAlgorithm => self.payload.InvalidAlgorithm == other.payload.InvalidAlgorithm,
                InvalidAlgorithmName => {
                    self.payload.InvalidAlgorithmName == other.payload.InvalidAlgorithmName
                }
                InvalidAudience => self.payload.InvalidAudience == other.payload.InvalidAudience,
                InvalidEcdsaKey => self.payload.InvalidEcdsaKey == other.payload.InvalidEcdsaKey,
                InvalidIssuer => self.payload.InvalidIssuer == other.payload.InvalidIssuer,
                InvalidKeyFormat => self.payload.InvalidKeyFormat == other.payload.InvalidKeyFormat,
                InvalidRsaKey => self.payload.InvalidRsaKey == other.payload.InvalidRsaKey,
                InvalidSignature => self.payload.InvalidSignature == other.payload.InvalidSignature,
                InvalidSubject => self.payload.InvalidSubject == other.payload.InvalidSubject,
                InvalidToken => self.payload.InvalidToken == other.payload.InvalidToken,
                Json => self.payload.Json == other.payload.Json,
                MissingAlgorithm => self.payload.MissingAlgorithm == other.payload.MissingAlgorithm,
                MissingRequiredClaim => {
                    self.payload.MissingRequiredClaim == other.payload.MissingRequiredClaim
                }
                RsaFailedSigning => self.payload.RsaFailedSigning == other.payload.RsaFailedSigning,
                UnspecifiedCrypto => {
                    self.payload.UnspecifiedCrypto == other.payload.UnspecifiedCrypto
                }
                Utf8 => self.payload.Utf8 == other.payload.Utf8,
            }
        }
    }
}

impl Ord for JwtErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for JwtErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_JwtErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    Base64 => self.payload.Base64.partial_cmp(&other.payload.Base64),
                    ExpiredSignature => self
                        .payload
                        .ExpiredSignature
                        .partial_cmp(&other.payload.ExpiredSignature),
                    ImmatureSignature => self
                        .payload
                        .ImmatureSignature
                        .partial_cmp(&other.payload.ImmatureSignature),
                    InvalidAlgorithm => self
                        .payload
                        .InvalidAlgorithm
                        .partial_cmp(&other.payload.InvalidAlgorithm),
                    InvalidAlgorithmName => self
                        .payload
                        .InvalidAlgorithmName
                        .partial_cmp(&other.payload.InvalidAlgorithmName),
                    InvalidAudience => self
                        .payload
                        .InvalidAudience
                        .partial_cmp(&other.payload.InvalidAudience),
                    InvalidEcdsaKey => self
                        .payload
                        .InvalidEcdsaKey
                        .partial_cmp(&other.payload.InvalidEcdsaKey),
                    InvalidIssuer => self
                        .payload
                        .InvalidIssuer
                        .partial_cmp(&other.payload.InvalidIssuer),
                    InvalidKeyFormat => self
                        .payload
                        .InvalidKeyFormat
                        .partial_cmp(&other.payload.InvalidKeyFormat),
                    InvalidRsaKey => self
                        .payload
                        .InvalidRsaKey
                        .partial_cmp(&other.payload.InvalidRsaKey),
                    InvalidSignature => self
                        .payload
                        .InvalidSignature
                        .partial_cmp(&other.payload.InvalidSignature),
                    InvalidSubject => self
                        .payload
                        .InvalidSubject
                        .partial_cmp(&other.payload.InvalidSubject),
                    InvalidToken => self
                        .payload
                        .InvalidToken
                        .partial_cmp(&other.payload.InvalidToken),
                    Json => self.payload.Json.partial_cmp(&other.payload.Json),
                    MissingAlgorithm => self
                        .payload
                        .MissingAlgorithm
                        .partial_cmp(&other.payload.MissingAlgorithm),
                    MissingRequiredClaim => self
                        .payload
                        .MissingRequiredClaim
                        .partial_cmp(&other.payload.MissingRequiredClaim),
                    RsaFailedSigning => self
                        .payload
                        .RsaFailedSigning
                        .partial_cmp(&other.payload.RsaFailedSigning),
                    UnspecifiedCrypto => self
                        .payload
                        .UnspecifiedCrypto
                        .partial_cmp(&other.payload.UnspecifiedCrypto),
                    Utf8 => self.payload.Utf8.partial_cmp(&other.payload.Utf8),
                }
            },
        }
    }
}

impl core::hash::Hash for JwtErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_JwtErr::*;

        unsafe {
            match self.discriminant {
                Base64 => self.payload.Base64.hash(state),
                ExpiredSignature => self.payload.ExpiredSignature.hash(state),
                ImmatureSignature => self.payload.ImmatureSignature.hash(state),
                InvalidAlgorithm => self.payload.InvalidAlgorithm.hash(state),
                InvalidAlgorithmName => self.payload.InvalidAlgorithmName.hash(state),
                InvalidAudience => self.payload.InvalidAudience.hash(state),
                InvalidEcdsaKey => self.payload.InvalidEcdsaKey.hash(state),
                InvalidIssuer => self.payload.InvalidIssuer.hash(state),
                InvalidKeyFormat => self.payload.InvalidKeyFormat.hash(state),
                InvalidRsaKey => self.payload.InvalidRsaKey.hash(state),
                InvalidSignature => self.payload.InvalidSignature.hash(state),
                InvalidSubject => self.payload.InvalidSubject.hash(state),
                InvalidToken => self.payload.InvalidToken.hash(state),
                Json => self.payload.Json.hash(state),
                MissingAlgorithm => self.payload.MissingAlgorithm.hash(state),
                MissingRequiredClaim => self.payload.MissingRequiredClaim.hash(state),
                RsaFailedSigning => self.payload.RsaFailedSigning.hash(state),
                UnspecifiedCrypto => self.payload.UnspecifiedCrypto.hash(state),
                Utf8 => self.payload.Utf8.hash(state),
            }
        }
    }
}

impl JwtErr {
    pub fn unwrap_Base64(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Base64);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Base64) }
    }

    pub fn borrow_Base64(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Base64);
        use core::borrow::Borrow;
        unsafe { self.payload.Base64.borrow() }
    }

    pub fn borrow_mut_Base64(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Base64);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Base64.borrow_mut() }
    }

    pub fn is_Base64(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::Base64)
    }

    pub fn is_ExpiredSignature(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::ExpiredSignature)
    }

    pub fn is_ImmatureSignature(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::ImmatureSignature)
    }

    pub fn is_InvalidAlgorithm(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidAlgorithm)
    }

    pub fn is_InvalidAlgorithmName(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidAlgorithmName)
    }

    pub fn is_InvalidAudience(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidAudience)
    }

    pub fn is_InvalidEcdsaKey(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidEcdsaKey)
    }

    pub fn is_InvalidIssuer(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidIssuer)
    }

    pub fn is_InvalidKeyFormat(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidKeyFormat)
    }

    pub fn unwrap_InvalidRsaKey(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::InvalidRsaKey);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.InvalidRsaKey) }
    }

    pub fn borrow_InvalidRsaKey(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::InvalidRsaKey);
        use core::borrow::Borrow;
        unsafe { self.payload.InvalidRsaKey.borrow() }
    }

    pub fn borrow_mut_InvalidRsaKey(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::InvalidRsaKey);
        use core::borrow::BorrowMut;
        unsafe { self.payload.InvalidRsaKey.borrow_mut() }
    }

    pub fn is_InvalidRsaKey(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidRsaKey)
    }

    pub fn is_InvalidSignature(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidSignature)
    }

    pub fn is_InvalidSubject(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidSubject)
    }

    pub fn is_InvalidToken(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::InvalidToken)
    }

    pub fn unwrap_Json(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Json);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Json) }
    }

    pub fn borrow_Json(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Json);
        use core::borrow::Borrow;
        unsafe { self.payload.Json.borrow() }
    }

    pub fn borrow_mut_Json(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Json);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Json.borrow_mut() }
    }

    pub fn is_Json(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::Json)
    }

    pub fn is_MissingAlgorithm(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::MissingAlgorithm)
    }

    pub fn unwrap_MissingRequiredClaim(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::MissingRequiredClaim);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.MissingRequiredClaim) }
    }

    pub fn borrow_MissingRequiredClaim(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::MissingRequiredClaim);
        use core::borrow::Borrow;
        unsafe { self.payload.MissingRequiredClaim.borrow() }
    }

    pub fn borrow_mut_MissingRequiredClaim(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::MissingRequiredClaim);
        use core::borrow::BorrowMut;
        unsafe { self.payload.MissingRequiredClaim.borrow_mut() }
    }

    pub fn is_MissingRequiredClaim(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::MissingRequiredClaim)
    }

    pub fn is_RsaFailedSigning(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::RsaFailedSigning)
    }

    pub fn is_UnspecifiedCrypto(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::UnspecifiedCrypto)
    }

    pub fn unwrap_Utf8(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Utf8);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Utf8) }
    }

    pub fn borrow_Utf8(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Utf8);
        use core::borrow::Borrow;
        unsafe { self.payload.Utf8.borrow() }
    }

    pub fn borrow_mut_Utf8(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_JwtErr::Utf8);
        use core::borrow::BorrowMut;
        unsafe { self.payload.Utf8.borrow_mut() }
    }

    pub fn is_Utf8(&self) -> bool {
        matches!(self.discriminant, discriminant_JwtErr::Utf8)
    }
}

impl JwtErr {
    pub fn Base64(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_JwtErr::Base64,
            payload: union_JwtErr {
                Base64: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn ExpiredSignature() -> Self {
        Self {
            discriminant: discriminant_JwtErr::ExpiredSignature,
            payload: union_JwtErr {
                ExpiredSignature: (),
            },
        }
    }

    pub fn ImmatureSignature() -> Self {
        Self {
            discriminant: discriminant_JwtErr::ImmatureSignature,
            payload: union_JwtErr {
                ImmatureSignature: (),
            },
        }
    }

    pub fn InvalidAlgorithm() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidAlgorithm,
            payload: union_JwtErr {
                InvalidAlgorithm: (),
            },
        }
    }

    pub fn InvalidAlgorithmName() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidAlgorithmName,
            payload: union_JwtErr {
                InvalidAlgorithmName: (),
            },
        }
    }

    pub fn InvalidAudience() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidAudience,
            payload: union_JwtErr {
                InvalidAudience: (),
            },
        }
    }

    pub fn InvalidEcdsaKey() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidEcdsaKey,
            payload: union_JwtErr {
                InvalidEcdsaKey: (),
            },
        }
    }

    pub fn InvalidIssuer() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidIssuer,
            payload: union_JwtErr { InvalidIssuer: () },
        }
    }

    pub fn InvalidKeyFormat() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidKeyFormat,
            payload: union_JwtErr {
                InvalidKeyFormat: (),
            },
        }
    }

    pub fn InvalidRsaKey(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidRsaKey,
            payload: union_JwtErr {
                InvalidRsaKey: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn InvalidSignature() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidSignature,
            payload: union_JwtErr {
                InvalidSignature: (),
            },
        }
    }

    pub fn InvalidSubject() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidSubject,
            payload: union_JwtErr { InvalidSubject: () },
        }
    }

    pub fn InvalidToken() -> Self {
        Self {
            discriminant: discriminant_JwtErr::InvalidToken,
            payload: union_JwtErr { InvalidToken: () },
        }
    }

    pub fn Json(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_JwtErr::Json,
            payload: union_JwtErr {
                Json: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn MissingAlgorithm() -> Self {
        Self {
            discriminant: discriminant_JwtErr::MissingAlgorithm,
            payload: union_JwtErr {
                MissingAlgorithm: (),
            },
        }
    }

    pub fn MissingRequiredClaim(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_JwtErr::MissingRequiredClaim,
            payload: union_JwtErr {
                MissingRequiredClaim: core::mem::ManuallyDrop::new(payload),
            },
        }
    }

    pub fn RsaFailedSigning() -> Self {
        Self {
            discriminant: discriminant_JwtErr::RsaFailedSigning,
            payload: union_JwtErr {
                RsaFailedSigning: (),
            },
        }
    }

    pub fn UnspecifiedCrypto() -> Self {
        Self {
            discriminant: discriminant_JwtErr::UnspecifiedCrypto,
            payload: union_JwtErr {
                UnspecifiedCrypto: (),
            },
        }
    }

    pub fn Utf8(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_JwtErr::Utf8,
            payload: union_JwtErr {
                Utf8: core::mem::ManuallyDrop::new(payload),
            },
        }
    }
}

impl Drop for JwtErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_JwtErr::Base64 => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Base64)
            },
            discriminant_JwtErr::ExpiredSignature => {}
            discriminant_JwtErr::ImmatureSignature => {}
            discriminant_JwtErr::InvalidAlgorithm => {}
            discriminant_JwtErr::InvalidAlgorithmName => {}
            discriminant_JwtErr::InvalidAudience => {}
            discriminant_JwtErr::InvalidEcdsaKey => {}
            discriminant_JwtErr::InvalidIssuer => {}
            discriminant_JwtErr::InvalidKeyFormat => {}
            discriminant_JwtErr::InvalidRsaKey => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.InvalidRsaKey)
            },
            discriminant_JwtErr::InvalidSignature => {}
            discriminant_JwtErr::InvalidSubject => {}
            discriminant_JwtErr::InvalidToken => {}
            discriminant_JwtErr::Json => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Json)
            },
            discriminant_JwtErr::MissingAlgorithm => {}
            discriminant_JwtErr::MissingRequiredClaim => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.MissingRequiredClaim)
            },
            discriminant_JwtErr::RsaFailedSigning => {}
            discriminant_JwtErr::UnspecifiedCrypto => {}
            discriminant_JwtErr::Utf8 => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.payload.Utf8)
            },
        }
    }
}

// NOTE this was manually implemented
impl roc_std::RocRefcounted for JwtErr {
    fn inc(&mut self) {
        match self.discriminant() {
            discriminant_JwtErr::Base64 => unsafe { (*self.payload.Base64).inc() },
            discriminant_JwtErr::ExpiredSignature => {}
            discriminant_JwtErr::ImmatureSignature => {}
            discriminant_JwtErr::InvalidAlgorithm => {}
            discriminant_JwtErr::InvalidAlgorithmName => {}
            discriminant_JwtErr::InvalidAudience => {}
            discriminant_JwtErr::InvalidEcdsaKey => {}
            discriminant_JwtErr::InvalidIssuer => {}
            discriminant_JwtErr::InvalidKeyFormat => {}
            discriminant_JwtErr::InvalidRsaKey => unsafe { (*self.payload.InvalidRsaKey).inc() },
            discriminant_JwtErr::InvalidSignature => {}
            discriminant_JwtErr::InvalidSubject => {}
            discriminant_JwtErr::InvalidToken => {}
            discriminant_JwtErr::Json => unsafe { (*self.payload.Json).inc() },
            discriminant_JwtErr::MissingAlgorithm => {}
            discriminant_JwtErr::MissingRequiredClaim => unsafe {
                (*self.payload.MissingRequiredClaim).inc()
            },
            discriminant_JwtErr::RsaFailedSigning => {}
            discriminant_JwtErr::UnspecifiedCrypto => {}
            discriminant_JwtErr::Utf8 => unsafe { (*self.payload.Utf8).inc() },
        }
    }
    fn dec(&mut self) {
        match self.discriminant() {
            discriminant_JwtErr::Base64 => unsafe { (*self.payload.Base64).dec() },
            discriminant_JwtErr::ExpiredSignature => {}
            discriminant_JwtErr::ImmatureSignature => {}
            discriminant_JwtErr::InvalidAlgorithm => {}
            discriminant_JwtErr::InvalidAlgorithmName => {}
            discriminant_JwtErr::InvalidAudience => {}
            discriminant_JwtErr::InvalidEcdsaKey => {}
            discriminant_JwtErr::InvalidIssuer => {}
            discriminant_JwtErr::InvalidKeyFormat => {}
            discriminant_JwtErr::InvalidRsaKey => unsafe { (*self.payload.InvalidRsaKey).dec() },
            discriminant_JwtErr::InvalidSignature => {}
            discriminant_JwtErr::InvalidSubject => {}
            discriminant_JwtErr::InvalidToken => {}
            discriminant_JwtErr::Json => unsafe { (*self.payload.Json).dec() },
            discriminant_JwtErr::MissingAlgorithm => {}
            discriminant_JwtErr::MissingRequiredClaim => unsafe {
                (*self.payload.MissingRequiredClaim).dec()
            },
            discriminant_JwtErr::RsaFailedSigning => {}
            discriminant_JwtErr::UnspecifiedCrypto => {}
            discriminant_JwtErr::Utf8 => unsafe { (*self.payload.Utf8).dec() },
        }
    }

    fn is_refcounted() -> bool {
        true
    }
}
